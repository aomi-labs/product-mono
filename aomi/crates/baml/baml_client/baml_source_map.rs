// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Embedded BAML source files.

use std::collections::HashMap;
use std::sync::OnceLock;

static FILE_MAP: OnceLock<HashMap<String, String>> = OnceLock::new();

/// Get the embedded BAML source files.
pub fn get_baml_files() -> &'static HashMap<String, String> {
    FILE_MAP.get_or_init(|| {
        let mut m = HashMap::new();

        m.insert("analyze_abi.baml".to_string(), "class CallableRetrieval {\n  name string @description(\"Name of the state variable or data being retrieved (e.g., 'totalSupply', 'balance', 'owner')\")\n  return_type string @description(\"Solidity return type (e.g., 'uint256', 'address', 'string', 'bool')\")\n  function_signature string @description(\"The function signature to call via eth_call (e.g., 'totalSupply()', 'balanceOf(address)')\")\n  requires_parameters bool @description(\"True if the function requires input parameters\")\n  parameter_types string[]? @description(\"Array of parameter types if requires_parameters is true (e.g., ['address']). Null otherwise\")\n  notes string? @description(\"Additional context about what this retrieves or any limitations\")\n}\n\nclass EventInfo {\n  description string @description(\"Description of what this event can be used to track (e.g., 'Logs transfers of tokens between addresses', 'Tracks addition/removal of validators')\")\n  event_signature string @description(\"Full Event signature including parameter types, indexed requirement, and parameter names (e.g., 'Transfer(address indexed from, address indexed to,uint256 value)', 'ValidatorAdded(uint256 indexed chainId, address validator)')\")\n  query_fields string[] @description(\"Fields relevant to user intent as (name, type) pairs, if intent is not specified, returns all relavant pairs. (e.g. Intent 'How much money has Alice spent' returns ['(from, address)', '(amount, u256)']; Intent 'track permissions', returns ['(proposer, address)', '(allowed, bool)'])\")\n}\n\nclass ABIAnalysisResult {\n  retrievals CallableRetrieval[] @description(\"List of all data that can be retrieved via eth_call using view/pure functions from the ABI\")\n  summary string @description(\"Brief summary of what data is accessible via eth_call from this contract\")\n  events EventInfo[] @description(\"List of all events that can be used to track changes\")\n}\n\nfunction AnalyzeABI(contract_info: ContractInfo, intent: string?) -> ABIAnalysisResult {\n  client CustomHaiku\n\n  prompt #\"\n    You are analyzing an Ethereum smart contract's ABI to identify what data can be retrieved via calling view functions and viewing event logs through RPC endpoints.\n\n    IMPORTANT: Only extract view/pure functions that retrieve contract state. Do NOT include:\n    - Write functions (nonpayable, payable)\n    - Functions that modify state\n    - Constructor or fallback functions\n\n    ---\n\n    {% if not contract_info.abi %}\n      {{ throw('ABI is required but not provided in contract_info') }}\n    {% endif %}\n\n    # Contract Information:\n    {% if contract_info.description %}\n    Description: {{ contract_info.description }}\n    {% endif %}\n    {% if contract_info.address %}\n    Address: {{ contract_info.address }}\n    {% endif %}\n    ABI: {{ contract_info.abi }}\n\n    ---\n\n    {% if intent %}\n    # User intent related to your tasks:\n    {{ intent }}\n    {% endif %}\n\n    ---\n\n    # Instructions:\n\n    1. **Identify all view/pure functions** in the ABI\n       - These have \"stateMutability\": \"view\" or \"stateMutability\": \"pure\"\n       - These are the ONLY functions you can use with eth_call to retrieve data\n\n    2. **For each view/pure function, extract**:\n       - name: What data it retrieves (often matches the function name)\n       - return_type: The return type from the \"outputs\" field\n       - function_signature: Complete signature including parameter types (e.g., \"balanceOf(address)\")\n       - requires_parameters: true if \"inputs\" is non-empty\n       - parameter_types: Array of input types if parameters are required\n       - notes: What this function retrieves and any special requirements (e.g., \"requires address parameter to check balance\")\n\n    3. **Key Rules**:\n       - ONLY include functions with stateMutability \"view\" or \"pure\"\n       - Function signature must match Solidity format: \"functionName(type1,type2)\"\n       - For functions with no parameters, use empty parentheses: \"totalSupply()\"\n       - For mappings like balanceOf, note that a key is required\n       - For functions returning multiple values, concatenate types (e.g., \"address,uint256\")\n\n    4. **Summary**:\n       - Count how many callable view/pure functions exist\n       - Briefly describe what types of data can be retrieved\n       - Note if this is a standard interface (ERC20, proxy, etc.)\n\n    ---\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest analyze_abi_usdc_implementation {\n  functions [AnalyzeABI]\n  args {\n    contract_info {\n      description \"Implementation of USDC stablecoin contract\"\n      address \"0x0882477e7895bdC5cea7cB1552ed914aB157Fe56\"\n      abi #\"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_currency\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_masterMinter\",\"type\":\"address\"},{\"name\":\"_pauser\",\"type\":\"address\"},{\"name\":\"_blacklister\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"},{\"name\":\"minterAllowedAmount\",\"type\":\"uint256\"}],\"name\":\"configureMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"minterAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMasterMinter\",\"type\":\"address\"}],\"name\":\"updateMasterMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBlacklister\",\"type\":\"address\"}],\"name\":\"updateBlacklister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blacklister\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minterAllowedAmount\",\"type\":\"uint256\"}],\"name\":\"MinterConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldMinter\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newMasterMinter\",\"type\":\"address\"}],\"name\":\"MasterMinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newBlacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]\"#\n    }\n    intent \"List all retrievable state variables and mappings with their retrieval methods\"\n  }\n}\n\ntest analyze_abi_usdc_proxy {\n  functions [AnalyzeABI]\n  args {\n    contract_info {\n      description \"The proxy of USDC stablecoin contract\"\n      address \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"\n      abi #\"[{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]\"#\n    }\n    intent \"Identify how to retrieve the implementation address and admin address\"\n  }\n}\n\ntest analyze_abi_simple_erc20 {\n  functions [AnalyzeABI]\n  args {\n    contract_info {\n      description \"A simple ERC20 token contract\"\n      address \"0x1234567890123456789012345678901234567890\"\n      abi #\"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]\"#\n    }\n    intent \"I'm interested in how much Alice has spent\"\n  }\n}".to_string());

        m.insert("analyze_contract.baml".to_string(), "// Call handler config\nclass CallHandlerConfig {\n  type string @description(\"Must be 'call'\")\n  method string @description(\"Function signature (e.g., 'owner()', 'balanceOf(address)')\")\n  args string[]? @description(\"Arguments if needed\")\n  ignoreRelative bool? @description(\"Don't follow this as a relative address\")\n  expectRevert bool? @description(\"Expect this call to revert\")\n  address string? @description(\"Call a different address\")\n}\n\n// Storage handler config\nclass StorageHandlerConfig {\n  type string @description(\"Must be 'storage'\")\n  slot string @description(\"Storage slot in hex format (e.g., '0x0', '0xa')\")\n  offset int? @description(\"Byte offset within slot for packed variables (0-31)\")\n  returnType string? @description(\"Solidity type to decode as (e.g., 'address', 'uint256')\")\n  ignoreRelative bool?\n}\n\n// AccessControl handler config\nclass AccessControlHandlerConfig {\n  type string @description(\"Must be 'accessControl'\")\n  roleNames map<string, string>? @description(\"Map COMPLETE 66-char role hash (0x + 64 hex) to name. Example: {'0xdf8b4c520ffe197c5343c6f5aec59570151ef9a492f2c624fd45ddde6135ec42': 'ADMIN'}\")\n  pickRoleMembers string? @description(\"Return only members of specific role (optional)\")\n  ignoreRelative bool?\n}\n\n// DynamicArray handler config\nclass DynamicArrayHandlerConfig {\n  type string @description(\"Must be 'dynamicArray'\")\n  slot string @description(\"Base storage slot for the array\")\n  returnType string? @description(\"Type of array elements\")\n  ignoreRelative bool?\n}\n\n// Union of all handler types\ntype HandlerConfig = CallHandlerConfig | StorageHandlerConfig | EventHandlerConfig | AccessControlHandlerConfig | DynamicArrayHandlerConfig\n\n// A field with its handler configuration\nclass FieldHandler {\n  fieldName string @description(\"Name for this field in discovered.json (e.g., 'owner', 'accessControl', 'whitelistedProposers')\")\n  config HandlerConfig @description(\"The handler configuration\")\n  description string? @description(\"Human-readable description of what this handler retrieves\")\n}\n\n// Complete analysis result\nclass ContractAnalysis {\n  handlers FieldHandler[] @description(\"All handlers to execute for this contract\")\n  patternDetected string? @description(\"Pattern detected (e.g., 'OpenZeppelin AccessControl', 'ERC20 Proxy', 'Custom Whitelist')\")\n  summary string @description(\"Brief summary of what these handlers will retrieve\")\n}\n\nfunction AnalyzeContractForHandlers(\n  contract_info: ContractInfo,\n  intent: string\n) -> ContractAnalysis {\n  client CustomHaiku\n\n  prompt #\"\n    You are analyzing an Ethereum smart contract to generate handler configurations.\n\n    # Contract Information\n\n    {% if contract_info.description %}\n    Description: {{ contract_info.description }}\n    {% endif %}\n\n    {% if contract_info.address %}\n    Address: {{ contract_info.address }}\n    {% endif %}\n\n    {% if contract_info.abi %}\n    ABI:\n    {{ contract_info.abi }}\n    {% endif %}\n\n    {% if contract_info.source_code %}\n    Source Code:\n    {{ contract_info.source_code }}\n    {% endif %}\n\n    ---\n\n    # User Intent\n\n    {{ intent }}\n\n    ---\n\n    # Your Task\n\n    Analyze the contract and generate handler configurations that will retrieve the data the user is interested in.\n    You should return MULTIPLE handlers of DIFFERENT types based on what patterns you detect.\n\n    ---\n\n    # Handler Selection Logic\n\n    ## 1. AccessControl Detection\n\n    **When to use:** Contract uses OpenZeppelin AccessControl pattern\n\n    **Detection criteria:**\n    - ABI contains events: `RoleGranted(bytes32,address,address)` and `RoleRevoked(bytes32,address,address)`\n    - Source code has role constant definitions\n\n    **Steps:**\n    1. Scan source code for role definitions:\n       ```solidity\n       bytes32 public constant ADMIN_ROLE = 0xdf8b4c52...\n       bytes32 public constant ORACLE_ROLE = 0x352d05fe...\n       ```\n    2. Extract COMPLETE 66-character role hashes (0x + 64 hex digits) - validate each hash is exactly 66 chars and contains only hex characters\n    3. Return AccessControlHandlerConfig with roleNames (only include valid 66-char hashes)\n\n    **Example output:**\n    - fieldName: \"accessControl\"\n    - handler.type: \"accessControl\"\n    - handler.roleNames: Map role hash 0xdf8b... to \"ADMIN_ROLE\", 0x352d... to \"ORACLE_ROLE\"\n    - description: \"OpenZeppelin AccessControl roles and members\"\n\n    ## 2. Event Pattern Detection\n\n    **When to use:** Events track sets/lists with add/remove semantics\n\n    **Detection criteria:**\n    - Events with boolean flags indicating add/remove\n    - Paired events (one for add, one for remove)\n    - Events that modify a set of addresses/values\n\n    **Example pattern:**\n    ```solidity\n    event ProposerPermissionUpdated(address proposer, bool allowed);\n    ```\n\n    **Steps:**\n    1. Identify the event that modifies the set\n    2. Determine which parameter to extract (the item being added/removed)\n    3. Determine the condition for add vs remove\n    4. Return EventHandlerConfig\n\n    **Example output:**\n    - fieldName: \"whitelistedProposers\"\n    - handler.type: \"event\"\n    - handler.select: \"proposer\"\n    - handler.add.event: \"ProposerPermissionUpdated\"\n    - handler.add.where: [\"=\", \"allowed\", true]\n    - handler.remove.event: \"ProposerPermissionUpdated\"\n    - handler.remove.where: [\"=\", \"allowed\", false]\n    - description: \"Set of addresses with proposer permissions\"\n\n    **Where clause format:**\n    - `[\"=\", \"fieldName\", value]` - Equality check\n    - `[\"!=\", \"fieldName\", value]` - Inequality check\n    - Use `#` prefix for event parameters\n\n    ## 3. Call Handler Detection\n\n    **When to use:** View/pure functions retrieve contract state\n\n    **Detection criteria:**\n    - Function has `stateMutability: \"view\"` or `\"pure\"` in ABI\n    - Function matches user intent\n    - Function doesn't require any parameters\n    - If Proxy pattern detected, SKIP call handlers and use Storage instead\n\n    **Steps:**\n    1. Filter ABI for view/pure functions with ZERO parameters (empty inputs array)\n    2. Only create handlers for functions that directly match user intent\n    3. Verify function exists in provided ABI before creating handler\n    4. For proxy contracts, prefer Storage handlers over Call handlers for implementation/admin\n\n    **Example output:**\n    - fieldName: \"owner\"\n    - handler.type: \"call\"\n    - handler.method: \"owner()\"\n    - handler.ignoreRelative: false\n    - description: \"Contract owner address\"\n\n    ## 4. Storage Handler Detection\n\n    **When to use:** Direct storage slot access needed (especially for proxies)\n\n    **Detection criteria:**\n    - Proxy pattern detected (EIP-1967, EIP-1822)\n    - Implementation/admin stored in specific slots\n    - No public getter available\n    - Use source code to determine exact slots\n\n    **Common proxy slots:**\n    - Implementation: `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n    - Admin: `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n\n    **Example output:**\n    - fieldName: \"implementation\"\n    - handler.type: \"storage\"\n    - handler.slot: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\n    - handler.returnType: \"address\"\n    - description: \"EIP-1967 implementation address\"\n\n    ## 5. DynamicArray Handler Detection\n\n    **When to use:** Dynamic arrays in storage need enumeration\n\n    **Detection criteria:**\n    - Source code shows dynamic array state variable\n    - Array needs to be fully enumerated\n    - No convenient getter function\n\n    **Example output:**\n    - fieldName: \"voters\"\n    - handler.type: \"dynamicArray\"\n    - handler.slot: \"0x2\"\n    - handler.returnType: \"address\"\n    - description: \"Array of all voter addresses\"\n\n    ---\n\n    # Important Rules\n\n    1. **Prioritize source code analysis** for event patterns and role detection\n       - Events signatures are in ABI, but semantics (add vs remove) require source code\n       - Role names require source code constant definitions\n\n    2. **Return multiple handlers** when appropriate\n       - A contract can have BOTH AccessControl AND Event handlers\n       - Don't limit yourself to one handler type\n\n    3. **Match intent carefully**\n       - If user asks for \"roles\", prioritize AccessControl handler\n       - If user asks for \"whitelisted addresses\", look for event-based tracking\n       - If user asks for \"implementation\", look for proxy patterns\n\n    4. **Use appropriate ignoreRelative flags**\n       - Set `ignoreRelative: true` for non-contract addresses (like admin EOAs)\n       - Set `ignoreRelative: false` for contract addresses that should be explored\n\n    5. **Field naming conventions**\n       - Use camelCase for field names\n       - Be descriptive but concise\n       - Examples: `owner`, `implementation`, `accessControl`, `whitelistedProposers`\n\n    6. **Filter out Call handlers**\n       - Filter out Call handlers for Proxy contracts, DO NOT include them in the output\n       - If the call requires parameter inputs, DO NOT include them in the output\n       - If the call doesn't exist on the contract, DO NOT include in the output\n\n    ---\n\n    # Output Format\n\n    Return a ContractAnalysis object with:\n    - **handlers**: Array of FieldHandler objects (fieldName + handler config + description)\n    - **patternDetected**: What pattern you recognized (optional but helpful)\n    - **summary**: Brief explanation of what these handlers will retrieve\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest analyze_usdc_proxy {\n  functions [AnalyzeContractForHandlers]\n  args {\n    contract_info {\n      description \"USDC Proxy Contract\"\n      address \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"\n      abi #\"[{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]\"#\n      source_code null\n    }\n    intent \"Find the implementation address and admin address\"\n  }\n}\n\ntest analyze_access_control_contract {\n  functions [AnalyzeContractForHandlers]\n  args {\n    contract_info {\n      description \"Contract with OpenZeppelin AccessControl\"\n      address \"0x1234567890123456789012345678901234567890\"\n      abi #\"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]\"#\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    bytes32 public constant ADMIN_ROLE = 0xdf8b4c520ffe197c5343c6f5aec59570151ef9a492f2c624fd45ddde6135ec42;\n    bytes32 public constant ORACLE_ROLE = 0x352d05fe3946dbe49277552ba941e744d5a96d9c60bc1ba0ea5f1d3ae000f7c8;\n    bytes32 public constant UPGRADER_ROLE = 0xa615a8afb6fffcb8c6809ac0997b5c9c12b8cc97651150f14c8f6203168cff4c;\n\n    function grantRole(bytes32 role, address account) public {\n        // implementation\n    }\n\n    function revokeRole(bytes32 role, address account) public {\n        // implementation\n    }\n}\n      \"#\n    }\n    intent \"Find all roles and their members\"\n  }\n}\n\ntest analyze_event_based_whitelist {\n  functions [AnalyzeContractForHandlers]\n  args {\n    contract_info {\n      description \"Contract with event-based proposer whitelist\"\n      address \"0xabcdef1234567890abcdef1234567890abcdef12\"\n      abi #\"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"ProposerPermissionUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]\"#\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ProposerRegistry {\n    address public owner;\n    mapping(address => bool) private proposers;\n\n    event ProposerPermissionUpdated(address indexed proposer, bool allowed);\n\n    function setProposerPermission(address proposer, bool allowed) public {\n        proposers[proposer] = allowed;\n        emit ProposerPermissionUpdated(proposer, allowed);\n    }\n}\n      \"#\n    }\n    intent \"Track which addresses have proposer permissions\"\n  }\n}\n".to_string());

        m.insert("analyze_event.baml".to_string(), "// AccessControl handler configuration matching Rust AccessControl\nclass AccessControlConfig {\n  event_signature string @description(\"Event signature for role changes, usually 'RoleGranted(...)' or 'RoleRevoked(...)'\")\n  role_names map<string, string>? @description(\"Mapping of human-readable role names to their hashes (e.g., {'ADMIN_ROLE': 'keccak256(\\\"ADMIN_ROLE\\\")'})\")\n  pick_role_members string? @description(\"Specific role to track when user intent narrows the scope (e.g., 'L2_TX_SENDER_ROLE')\")\n}\n\n\n// Event action configuration for discovered.json\nclass EventAction {\n  field_name string @description(\"Identifier for the tracked value (e.g., 'validatorsByChain', 'proxyAdmin')\")\n  action_description string @description(\"Human-readable explanation of what the handler collects\")\n  handler EventHandlerConfig | AccessControlConfig @description(\"Handler parameters describing how to stream the data from logs\")\n}\n\n// Complete event analysis output\nclass EventAnalyzeResult {\n  event_actions EventAction[] @description(\"Generated retrieval operations describing how to read dynamic state from events\")\n  detected_constants map<string, string>? @description(\"Important constants (role hashes, chain IDs, addresses) used in filters\")\n  proxy_pattern string? @description(\"If this contract manages an upgradeable proxy, summarize the pattern\")\n  summary string @description(\"Overview of tracked event actions and how they satisfy the intent\")\n  warnings string[]? @description(\"Open questions or gaps (missing events, ambiguous semantics, etc.)\")\n}\n\nfunction AnalyzeEvent(contract_info: ContractInfo, abi_result: ABIAnalysisResult, intent: string?) -> EventAnalyzeResult {\n  client CustomHaiku\n\n  prompt #\"\n    You are analyzing Ethereum smart contract source code to design event-driven handlers that track dynamic state over time.\n\n    ---\n\n    {% if not contract_info.source_code %}\n      {{ throw('Source code is required but not provided in contract_info') }}\n    {% endif %}\n\n    # Contract Information:\n    {% if contract_info.description %}\n    Description: {{ contract_info.description }}\n    {% endif %}\n    {% if contract_info.address %}\n    Address: {{ contract_info.address }}\n    {% endif %}\n    Source Code:\n    {{ contract_info.source_code }}\n\n    ---\n\n    # ABI Analysis Results (pre-parsed callable functions and events):\n    {{ abi_result }}\n\n    ---\n\n    {% if intent %}\n    # User Intent:\n    {{ intent }}\n    {% endif %}\n\n    ---\n\n    ## Responsibilities\n\n    1. **Determine what should be tracked**\n       - Use the user intent (when provided) plus contract semantics to decide which values require historical tracking.\n       - Prioritize items that change over time: validator sets, configuration parameters, role memberships, proxy admin/implementation, toggles, etc.\n\n    2. **Create EventAction entries**\n       - `field_name`: concise machine-friendly identifier (camelCase or snake_case) describing the tracked data.\n       - `action_description`: 1–2 sentences that explain what is being retrieved and how it changes.\n       - `handler`: choose between\n         * **EventHandlerConfig** for general events.\n           - `event_signature`: include when a single event both identifies and updates the value (omit when using explicit add/remove operations).\n           - `select_field`: parameter name from the ABI event definition representing the tracked value.\n           - `return_type`: parameter type from the ABI.\n           - `add` / `remove`: use when separate events add or remove items. Provide the full event signature and optional `where` filters.\n         * **AccessControlConfig** when RoleGranted/RoleRevoked patterns exist. Populate `role_names` with discovered constants and use `pick_role_members` to focus on the relevant role.\n\n    3. **Leverage ABI metadata**\n       - Reuse exact event signatures and parameter names from `abi_result.events`.\n       - When filters are required (e.g., specific `chainId`), express them as `['operator', '#field', 'value']`. Literal numbers should be strings.\n\n    4. **detected_constants**\n       - Surface constants referenced in filters or useful to downstream consumers (role hashes, chain IDs, sentinel addresses).\n\n    5. **proxy_pattern**\n       - If the contract is a proxy or emits upgrade-related events, summarize how admin/implementation changes are emitted.\n\n    6. **summary & warnings**\n       - Summarize the generated handlers and their relationship to the intent.\n       - Record missing or ambiguous pieces in `warnings` (e.g., \"No removal event found for validator set\").\n\n    ## Guidance\n    - Do not invent events that are not present in the ABI or source.\n    - Prefer explicit add/remove semantics when available over boolean flags.\n    - If events emit only a boolean toggle (e.g., `OperatorStatusChanged(address,bool)`), treat `true` as add and `false` as remove.\n    - When uncertain about semantics, note the assumption in `warnings`.\n\n    ---\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest analyze_event_validator_manager {\n  functions [AnalyzeEvent]\n  args {\n    contract_info {\n      description \"Validator membership manager with add/remove events\"\n      address \"0x1111111111111111111111111111111111111111\"\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ValidatorManager {\n    mapping(uint256 => mapping(address => bool)) public validators;\n    event ValidatorAdded(uint256 indexed chainId, address indexed validator);\n    event ValidatorRemoved(uint256 indexed chainId, address indexed validator);\n}\n      \"#\n    }\n    abi_result {\n      retrievals [\n        {\n          name \"validators\"\n          return_type \"bool\"\n          function_signature \"validators(uint256,address)\"\n          requires_parameters true\n          parameter_types [\"uint256\", \"address\"]\n          notes null\n        }\n      ]\n      events [\n        {\n          event_signature \"ValidatorAdded(uint256 indexed chainId, address indexed validator)\"\n          description \"Emitted when a validator becomes active for a specific chain\"\n          query_fields [\"(chainId, uint256)\", \"(validator, address)\"]\n        },\n        {\n          event_signature \"ValidatorRemoved(uint256 indexed chainId, address indexed validator)\"\n          description \"Emitted when a validator is removed from a chain\"\n          query_fields [\"(chainId, uint256)\", \"(validator, address)\"]\n        }\n      ]\n      summary \"1 callable function and 2 membership events\"\n    }\n    intent \"Track validators for chainId 325 using ValidatorAdded/ValidatorRemoved events\"\n  }\n}\n\ntest analyze_event_access_control {\n  functions [AnalyzeEvent]\n  args {\n    contract_info {\n      description \"Access Control example with role constants\"\n      address \"0x2222222222222222222222222222222222222222\"\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract L2MessagePasser is AccessControl {\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 public constant L2_TX_SENDER_ROLE = keccak256(\"L2_TX_SENDER_ROLE\");\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    mapping(address => bool) public whitelistedSenders;\n\n    function addWhitelistedSender(address sender) external onlyRole(ADMIN_ROLE) {\n        whitelistedSenders[sender] = true;\n        _grantRole(L2_TX_SENDER_ROLE, sender);\n    }\n}\n      \"#\n    }\n    abi_result {\n      retrievals [\n        {\n          name \"L2_TX_SENDER_ROLE\"\n          return_type \"bytes32\"\n          function_signature \"L2_TX_SENDER_ROLE()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"ADMIN_ROLE\"\n          return_type \"bytes32\"\n          function_signature \"ADMIN_ROLE()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"whitelistedSenders\"\n          return_type \"bool\"\n          function_signature \"whitelistedSenders(address)\"\n          requires_parameters true\n          parameter_types [\"address\"]\n          notes null\n        }\n      ]\n      events [\n        {\n          event_signature \"RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)\"\n          description \"Standard AccessControl event fired when a role is granted to an account\"\n          query_fields [\"(role, bytes32)\", \"(account, address)\", \"(sender, address)\"]\n        },\n        {\n          event_signature \"RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)\"\n          description \"AccessControl event fired when a role is revoked from an account\"\n          query_fields [\"(role, bytes32)\", \"(account, address)\", \"(sender, address)\"]\n        }\n      ]\n      summary \"3 callable functions and 2 access control events\"\n    }\n    intent \"List addresses that ever received the L2_TX_SENDER_ROLE\"\n  }\n}\n\ntest analyze_event_proxy_tracking {\n  functions [AnalyzeEvent]\n  args {\n    contract_info {\n      description \"Transparent proxy emitting admin and implementation changes\"\n      address \"0x3333333333333333333333333333333333333333\"\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract CustomProxy is TransparentUpgradeableProxy {\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event Upgraded(address indexed implementation);\n    event ProxyInitialized(address implementation, address admin);\n}\n      \"#\n    }\n    abi_result {\n      retrievals [\n        {\n          name \"getImplementation\"\n          return_type \"address\"\n          function_signature \"getImplementation()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"getAdmin\"\n          return_type \"address\"\n          function_signature \"getAdmin()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        }\n      ]\n      events [\n        {\n          event_signature \"AdminChanged(address previousAdmin, address newAdmin)\"\n          description \"Transparent proxy event noting a change in the proxy admin\"\n          query_fields [\"(previousAdmin, address)\", \"(newAdmin, address)\"]\n        },\n        {\n          event_signature \"Upgraded(address indexed implementation)\"\n          description \"Transparent proxy event emitted when the implementation logic changes\"\n          query_fields [\"(implementation, address)\"]\n        },\n        {\n          event_signature \"ProxyInitialized(address implementation, address admin)\"\n          description \"Initialization event capturing the first implementation and admin\"\n          query_fields [\"(implementation, address)\", \"(admin, address)\"]\n        }\n      ]\n      summary \"2 getter functions and 3 proxy events\"\n    }\n    intent null\n  }\n}\n".to_string());

        m.insert("analyze_layout.baml".to_string(), "// Storage slot description returned by the layout analysis\nclass SlotInfo {\n  name string @description(\"Variable name from source code (prefix parent contract if helpful)\")\n  type string @description(\"Solidity type from source code (e.g., 'address', 'mapping(uint256 => address)')\")\n  base_slot string? @description(\"Base storage slot index in hex (e.g., '0x0', '0x1'). For packed/shared slots this is the shared slot\")\n  offset int? @description(\"Byte offset within the slot for packed variables (0-31). Null for standalone 32-byte slots\")\n  getter_signature string? @description(\"Getter signature if the ABI exposes this variable (e.g., 'owner()', 'validators(uint256,address)')\")\n  notes string? @description(\"Additional context about purpose, packing, or structure memberships\")\n}\n\n\n// Complete storage analysis output\nclass LayoutAnalysisResult {\n  contract_name string @description(\"Primary contract under analysis, usually the last contract defined\")\n  solidity_version string? @description(\"Solidity version from pragma (e.g., '^0.8.0', '0.6.12')\")\n  inheritance string @description(\"Linearized inheritance chain (e.g., 'MyToken -> ERC20 -> Context')\")\n  slots SlotInfo[] @description(\"Detailed storage slot mapping for all state variables\")\n  detected_constants map<string, string>? @description(\"Important constants encountered (role hashes, admin slots, etc.)\")\n  proxy_pattern string? @description(\"If contract implements a proxy or delegate pattern, summarize it\")\n  summary string @description(\"High-level overview of storage layout with respect to the user intent\")\n  warnings string[]? @description(\"Uncertainties or assumptions called out during analysis\")\n}\n\nfunction AnalyzeLayout(contract_info: ContractInfo, abi_result: ABIAnalysisResult, intent: string) -> LayoutAnalysisResult {\n  client CustomHaiku\n\n  prompt #\"\n    You are analyzing Ethereum smart contract source code to map the storage layout that backs on-chain state.\n\n    ---\n\n    {% if not contract_info.source_code %}\n      {{ throw('Source code is required but not provided in contract_info') }}\n    {% endif %}\n\n    # Contract Information:\n    {% if contract_info.description %}\n    Description: {{ contract_info.description }}\n    {% endif %}\n    {% if contract_info.address %}\n    Address: {{ contract_info.address }}\n    {% endif %}\n    Source Code:\n    {{ contract_info.source_code }}\n\n    ---\n\n    # ABI Analysis Results (previously identified view functions and events):\n    {{ abi_result }}\n\n    ---\n\n    # User Intent:\n    {{ intent }}\n\n    ---\n\n    ## Output requirements\n\n    1. **contract_name & solidity_version**\n       - Identify the primary contract to analyze (typically the last or most feature-complete contract).\n       - Extract the pragma statement and report the Solidity version range.\n\n    2. **Inheritance map**\n       - Produce a string describing the linearized inheritance order (e.g., `Child -> ParentA -> ParentB`).\n       - Apply Solidity’s linearization rules: expand each parent’s bases before moving right, deduplicate shared ancestors.\n\n    3. **slots (SlotInfo[])**\n       - Enumerate every state variable following the inheritance chain (parents first, then child declarations).\n       - Populate each `SlotInfo` with:\n         * `name`: variable name; prefix with parent contract if needed to disambiguate.\n         * `type`: exact Solidity type from source.\n         * `base_slot`: sequential slot index in hex (`0x0`, `0x1`, …) representing where the variable (or pointer) is stored.\n             - For mappings or dynamic arrays, use the slot that stores the seed/pointer.\n             - For structs or fixed-size arrays, use the head slot and describe layout in `notes`.\n         * `offset`: byte offset (0–31) only when multiple packed variables share the slot; otherwise null.\n         * `getter_signature`: if `abi_result.retrievals` exposes a getter, provide the signature (`balanceOf(address)`, `owner()`).\n         * `notes`: concise explanation of purpose, packing, struct members, or special calculation details.\n       - Call out intentionally skipped/reserved slots in `notes`.\n\n    4. **detected_constants**\n       - Include role hashes, special storage slot constants, fixed addresses, or other meaningful literals.\n       - Map human-readable keys to the literal value (e.g., `\"ADMIN_ROLE\": \"keccak256(\\\"ADMIN_ROLE\\\")\"`).\n\n    5. **proxy_pattern**\n       - If the contract is a proxy or manipulates implementation/admin slots, summarize the pattern and its intent.\n\n    6. **summary**\n       - Provide 2–3 sentences highlighting variable counts, notable mappings/arrays, and intent-relevant state.\n\n    7. **warnings**\n       - List uncertainties or ambiguous deductions (e.g., \"struct members truncated in provided source\"). Omit when unnecessary.\n\n    ## Guidance\n    - Follow Solidity declaration order strictly; never invent slot numbers that conflict with inheritance rules.\n    - Emit slot indices in hex. For packed slots, increment offsets in ascending order.\n    - Prefer concrete facts from source; when unsure, document the uncertainty in `warnings` instead of guessing.\n\n    ---\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest analyze_layout_validator_manager {\n  functions [AnalyzeLayout]\n  args {\n    contract_info {\n      description \"Manages validator membership per chain\"\n      address \"0x1111111111111111111111111111111111111111\"\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ValidatorManager {\n    address public owner;\n    mapping(uint256 => mapping(address => bool)) public validators;\n    uint256 public minimumStake;\n    bool public emergencyExitEnabled;\n\n    event ValidatorAdded(uint256 indexed chainId, address indexed validator);\n    event ValidatorRemoved(uint256 indexed chainId, address indexed validator);\n    event EmergencyExitToggled(bool enabled);\n}\n      \"#\n    }\n    abi_result {\n      retrievals [\n        {\n          name \"owner\"\n          return_type \"address\"\n          function_signature \"owner()\"\n          requires_parameters false\n          parameter_types null\n          notes \"Returns the current owner\"\n        },\n        {\n          name \"validators\"\n          return_type \"bool\"\n          function_signature \"validators(uint256,address)\"\n          requires_parameters true\n          parameter_types [\"uint256\", \"address\"]\n          notes \"Returns whether validator is active on a chain\"\n        },\n        {\n          name \"minimumStake\"\n          return_type \"uint256\"\n          function_signature \"minimumStake()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"emergencyExitEnabled\"\n          return_type \"bool\"\n          function_signature \"emergencyExitEnabled()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        }\n      ]\n      events [\n        {\n          event_signature \"ValidatorAdded(uint256 indexed chainId, address indexed validator)\"\n          description \"Emitted when a validator is activated for a given chain\"\n          query_fields [\"(chainId, uint256)\", \"(validator, address)\"]\n        },\n        {\n          event_signature \"ValidatorRemoved(uint256 indexed chainId, address indexed validator)\"\n          description \"Emitted when a validator is deactivated for a given chain\"\n          query_fields [\"(chainId, uint256)\", \"(validator, address)\"]\n        },\n        {\n          event_signature \"EmergencyExitToggled(bool enabled)\"\n          description \"Records toggling of the emergency exit mode\"\n          query_fields [\"(enabled, bool)\"]\n        }\n      ]\n      summary \"4 callable functions and 3 events\"\n    }\n    intent \"Document storage used to track validators, stakes, and emergency exits\"\n  }\n}\n\ntest analyze_layout_access_control {\n  functions [AnalyzeLayout]\n  args {\n    contract_info {\n      description \"Access controlled message passer using role constants\"\n      address \"0x2222222222222222222222222222222222222222\"\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract L2MessagePasser is AccessControl {\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 public constant L2_TX_SENDER_ROLE = keccak256(\"L2_TX_SENDER_ROLE\");\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    mapping(address => bool) public whitelistedSenders;\n    uint256 public messageCount;\n    bool public paused;\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n    }\n}\n      \"#\n    }\n    abi_result {\n      retrievals [\n        {\n          name \"DEFAULT_ADMIN_ROLE\"\n          return_type \"bytes32\"\n          function_signature \"DEFAULT_ADMIN_ROLE()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"L2_TX_SENDER_ROLE\"\n          return_type \"bytes32\"\n          function_signature \"L2_TX_SENDER_ROLE()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"ADMIN_ROLE\"\n          return_type \"bytes32\"\n          function_signature \"ADMIN_ROLE()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"whitelistedSenders\"\n          return_type \"bool\"\n          function_signature \"whitelistedSenders(address)\"\n          requires_parameters true\n          parameter_types [\"address\"]\n          notes null\n        },\n        {\n          name \"messageCount\"\n          return_type \"uint256\"\n          function_signature \"messageCount()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"paused\"\n          return_type \"bool\"\n          function_signature \"paused()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        }\n      ]\n      events [\n        {\n          event_signature \"RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)\"\n          description \"AccessControl grant event linking role hashes to accounts\"\n          query_fields [\"(role, bytes32)\", \"(account, address)\", \"(sender, address)\"]\n        },\n        {\n          event_signature \"RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)\"\n          description \"AccessControl revoke event describing role removals\"\n          query_fields [\"(role, bytes32)\", \"(account, address)\", \"(sender, address)\"]\n        }\n      ]\n      summary \"6 callable functions and 2 access control events\"\n    }\n    intent \"Surface storage slots relevant to managing role-protected messaging\"\n  }\n}\n\ntest analyze_layout_proxy_contract {\n  functions [AnalyzeLayout]\n  args {\n    contract_info {\n      description \"TransparentUpgradeableProxy wrapper exposing implementation and admin getters\"\n      address \"0x3333333333333333333333333333333333333333\"\n      source_code #\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract CustomProxy is TransparentUpgradeableProxy {\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    constructor(address implementation, address admin, bytes memory data)\n        TransparentUpgradeableProxy(implementation, admin, data)\n    {}\n}\n      \"#\n    }\n    abi_result {\n      retrievals [\n        {\n          name \"getImplementation\"\n          return_type \"address\"\n          function_signature \"getImplementation()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        },\n        {\n          name \"getAdmin\"\n          return_type \"address\"\n          function_signature \"getAdmin()\"\n          requires_parameters false\n          parameter_types null\n          notes null\n        }\n      ]\n      events [\n        {\n          event_signature \"AdminChanged(address previousAdmin, address newAdmin)\"\n          description \"Proxy event signaling an admin change\"\n          query_fields [\"(previousAdmin, address)\", \"(newAdmin, address)\"]\n        },\n        {\n          event_signature \"Upgraded(address indexed implementation)\"\n          description \"Proxy event signaling an implementation upgrade\"\n          query_fields [\"(implementation, address)\"]\n        },\n        {\n          event_signature \"ProxyInitialized(address implementation, address admin)\"\n          description \"Proxy constructor-style event capturing initial admin and implementation\"\n          query_fields [\"(implementation, address)\", \"(admin, address)\"]\n        }\n      ]\n      summary \"2 callable functions and 3 proxy events\"\n    }\n    intent \"Identify proxy-specific storage slots and constants for upgrade tracking\"\n  }\n}\n".to_string());

        m.insert("clients.baml".to_string(), "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// Using the new OpenAI Responses API for enhanced formatting\nclient<llm> CustomGPT5 {\n  provider openai-responses\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT5Mini {\n  provider openai-responses\n  retry_policy Exponential\n  options {\n    model \"gpt-5-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Openai with chat completion\nclient<llm> CustomGPT5Chat {\n  provider openai\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Latest Anthropic Claude 4 models\nclient<llm> CustomOpus4 {\n  provider anthropic\n  options {\n    model \"claude-opus-4-1-20250805\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet4 {\n  provider anthropic\n  options {\n    model \"claude-sonnet-4-20250514\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-5-haiku-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// Example Google AI client (uncomment to use)\n// client<llm> CustomGemini {\n//   provider google-ai\n//   options {\n//     model \"gemini-2.5-pro\"\n//     api_key env.GOOGLE_API_KEY\n//   }\n// }\n\n// Example AWS Bedrock client (uncomment to use)\n// client<llm> CustomBedrock {\n//   provider aws-bedrock\n//   options {\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\n//     region \"us-east-1\"\n//     // AWS credentials are auto-detected from env vars\n//   }\n// }\n\n// Example Azure OpenAI client (uncomment to use)\n// client<llm> CustomAzure {\n//   provider azure-openai\n//   options {\n//     model \"gpt-5\"\n//     api_key env.AZURE_OPENAI_API_KEY\n//     base_url \"https://MY_RESOURCE_NAME.openai.azure.com/openai/deployments/MY_DEPLOYMENT_ID\"\n//     api_version \"2024-10-01-preview\"\n//   }\n// }\n\n// Example Vertex AI client (uncomment to use)\n// client<llm> CustomVertex {\n//   provider vertex-ai\n//   options {\n//     model \"gemini-2.5-pro\"\n//     location \"us-central1\"\n//     // Uses Google Cloud Application Default Credentials\n//   }\n// }\n\n// Example Ollama client for local models (uncomment to use)\n// client<llm> CustomOllama {\n//   provider openai-generic\n//   options {\n//     base_url \"http://localhost:11434/v1\"\n//     model \"llama4\"\n//     default_role \"user\" // Most local models prefer the user role\n//     // No API key needed for local Ollama\n//   }\n// }\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT5Mini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT5Mini, CustomGPT5]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}".to_string());

        m.insert("forge_executor.baml".to_string(), "// ============================================================================\n// Forge Executor: Two-Phase Script Generation\n// ============================================================================\n\n// ============================================================================\n// Phase 1: Extract Relevant Contract Information\n// ============================================================================\n\nclass ContractInfo {\n    description string?     @description(\"Optional human description of the contract\")\n    address string          @description(\"Contract address, e.g., '0x295a70b2de5e3953354a6a8344e616ed314d7251'\")\n    abi string              @description(\"Full ABI JSON string\")\n    source_code string?     @description(\"Full Solidity source code (if available)\")\n}\n\nclass Function {\n    description string?     @description(\"Description of what this function does\")\n    signature string        @description(\"Function signature in Solidity, e.g., 'wrap()' or 'addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)'\")\n    abi string              @description(\"JSON snippet for this function from the ABI\")\n    body string?            @description(\"Function body from source code (if available)\")\n    arguments string?       @description(\"Human-readable description of arguments, if helpful\")\n}\n\nclass Storage {\n    description string?     @description(\"What is stored in this variable\")\n    declaration string?     @description(\"Declaration from source code, e.g., 'uint256 public totalSupply;'\")\n    index int?              @description(\"Order of declaration in the contract (e.g., this is the 5th variable)\")\n}\n\nclass Event {\n    signature string        @description(\"Event signature in Solidity, e.g., 'Transfer(address indexed from, address indexed to, uint256 value)'\")\n    abi string              @description(\"JSON snippet for this event from the ABI\")\n}\n\nclass ExtractedContractInfo {\n    description string?     @description(\"Optional description of the contract\")\n    address string          @description(\"Contract address\")\n    interface_name string   @description(\"Interface name to use, e.g., 'IWETH', 'IQuoter', 'IERC20'\")\n    functions Function[]    @description(\"Functions needed for this operation group\")\n    storages Storage[]      @description(\"Storage variables accessed\")\n    events Event[]          @description(\"Events emitted or read\")\n}\n\nfunction ExtractContractInfo(\n    group_operations: string[],\n    contracts: ContractInfo[]\n) -> ExtractedContractInfo[] {\n    client CustomHaiku\n    prompt #\"\n        You are analyzing smart contracts to extract relevant information for executing operations.\n\n        Given these operations:\n        {{ group_operations }}\n\n        And these contracts with full ABIs and source code:\n        {{ contracts }}\n\n        For EACH contract, extract:\n        1. Which functions are needed to perform the operations?\n        2. What storage variables might be accessed (if source code available)?\n        3. What events might be emitted?\n\n        Create a concise interface name (e.g., IWETH, IQuoter, IERC20).\n        Include function bodies if available to understand behavior.\n        Only include items that are relevant to the operations.\n\n        {{ ctx.output_format }}\n    \"#\n}\n\n// ============================================================================\n// Phase 2: Generate Forge Script\n// ============================================================================\n\nclass Import {\n    interface_name string   @description(\"Interface name, e.g., 'IERC20'\")\n    source string           @description(\"Import source path, e.g., 'forge-std/interfaces/IERC20.sol'\")\n}\n\nclass Interface {\n    name string             @description(\"Interface name, e.g., 'IWETH'\")\n    solidity_code string    @description(\"Complete Solidity interface definition, e.g., 'interface IWETH { function wrap() external payable; }'\")\n}\n\nclass CodeLine {\n    line string             @description(\"Solidity code line, e.g., 'IWETH(0xC02...).wrap{value: ethAmount}();'\")\n    import_spec Import?     @description(\"If this line needs a forge-std import, specify it here\")\n    interface Interface?    @description(\"If this line needs a custom interface definition, specify it here\")\n}\n\nclass ScriptBlock {\n    codelines CodeLine[]    @description(\"List of code lines in execution order\")\n}\n\nfunction GenerateScript(\n    group_operations: string[],\n    extracted_infos: ExtractedContractInfo[]\n) -> ScriptBlock {\n    client \"openai-responses/gpt-5-mini\"\n    prompt #\"\n        You are a Solidity code generator for Forge scripts. Generate clean, correct Solidity code from operation descriptions. Make sure you follow Solidity syntax and best practices.\n        Keep in mind that the code lines you generate will be placed in a function between vm.startBroadcast() and vm.stopBroadcast().\n        Ensure the generated code lines are self-contained within this script and only reference identifiers defined in these lines.\n        Ensure all lines are valid Solidity syntax (correct type/keyword order, semicolons, and properly declared variables).\n\n        Operations to perform:\n        {{ group_operations }}\n\n        Using extracted contract information:\n        {{ extracted_infos }}\n\n        For each operation, generate Solidity code lines:\n        1. Parse the natural language to understand:\n           - What function to call\n           - What parameters are needed (amounts, addresses, etc.)\n           - Whether ETH value is required (for payable functions)\n\n        2. Generate the Solidity code:\n           - Use the interface name to cast addresses: `InterfaceName(address).functionName(params)`\n           - For deployments: `ContractName varName = new ContractName(params);`\n           - For payable calls: `InterfaceName(address).functionName{value: amount}(params)`\n           - Use proper Solidity types and formatting\n\n        3. Handle special cases:\n           - ETH amounts: use `0.75 ether` or `75 * 10**16` for readability\n           - Addresses: use checksummed format or keep as provided\n           - Placeholders like {$X}: keep them as variable names (e.g., `uint256 X = ...;`)\n           - Variable references: if description says \"use result from X\", create appropriate variable\n\n        4. For each code line, decide on import vs inline interface:\n           - If it's a standard forge-std interface (IERC20, IERC721, etc.): set `import_spec`\n           - If it's a custom interface (IWETH, IQuoter, etc.): set `interface` with full definition\n           - Only one of `import_spec` or `interface` should be set, not both\n\n        Example output:\n        ```json\n        {\n          \"codelines\": [\n            {\n              \"line\": \"uint256 ethAmount = 75 * 10**16;\",\n              \"import_spec\": null,\n              \"interface\": null\n            },\n            {\n              \"line\": \"IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).wrap{value: ethAmount}();\",\n              \"import_spec\": null,\n              \"interface\": {\n                \"name\": \"IWETH\",\n                \"solidity_code\": \"interface IWETH { function wrap() external payable; }\"\n              }\n            },\n            {\n              \"line\": \"IERC20 token = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\",\n              \"import_spec\": {\n                \"interface_name\": \"IERC20\",\n                \"source\": \"forge-std/interfaces/IERC20.sol\"\n              },\n              \"interface\": null\n            }\n          ]\n        }\n        ```\n\n        {{ ctx.output_format }}\n    \"#\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\ntest ExtractContractInfoTest {\n    functions [ExtractContractInfo]\n    args {\n        group_operations [\n            \"wrap 0.75 ETH to WETH by calling wrap() function\",\n            \"quote swap of 0.75 WETH to USDC using Uniswap V3 Quoter with 0.3% fee tier\"\n        ]\n        contracts [\n            {\n                description: \"Wrapped ETH contract\"\n                address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"\n                abi: \"[{\\\"name\\\":\\\"wrap\\\",\\\"type\\\":\\\"function\\\",\\\"stateMutability\\\":\\\"payable\\\",\\\"inputs\\\":[],\\\"outputs\\\":[]}]\"\n                source_code: \"contract WETH { function wrap() external payable { balances[msg.sender] += msg.value; } }\"\n            },\n            {\n                description: \"Uniswap V3 Quoter for quoting swap amounts\"\n                address: \"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6\"\n                abi: \"[{\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"quoteExactInputSingle\\\",\\\"inputs\\\":[{\\\"name\\\":\\\"params\\\",\\\"type\\\":\\\"tuple\\\",\\\"internalType\\\":\\\"struct IQuoter.QuoteExactInputSingleParams\\\",\\\"components\\\":[{\\\"name\\\":\\\"tokenIn\\\",\\\"type\\\":\\\"address\\\",\\\"internalType\\\":\\\"address\\\"},{\\\"name\\\":\\\"tokenOut\\\",\\\"type\\\":\\\"address\\\",\\\"internalType\\\":\\\"address\\\"},{\\\"name\\\":\\\"amountIn\\\",\\\"type\\\":\\\"uint256\\\",\\\"internalType\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"fee\\\",\\\"type\\\":\\\"uint24\\\",\\\"internalType\\\":\\\"uint24\\\"},{\\\"name\\\":\\\"sqrtPriceLimitX96\\\",\\\"type\\\":\\\"uint160\\\",\\\"internalType\\\":\\\"uint160\\\"}]}],\\\"outputs\\\":[{\\\"name\\\":\\\"amountReceived\\\",\\\"type\\\":\\\"uint256\\\",\\\"internalType\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"sqrtPriceX96After\\\",\\\"type\\\":\\\"uint160\\\",\\\"internalType\\\":\\\"uint160\\\"},{\\\"name\\\":\\\"initializedTicksCrossed\\\",\\\"type\\\":\\\"uint32\\\",\\\"internalType\\\":\\\"uint32\\\"},{\\\"name\\\":\\\"gasEstimate\\\",\\\"type\\\":\\\"uint256\\\",\\\"internalType\\\":\\\"uint256\\\"}],\\\"stateMutability\\\":\\\"view\\\"}]\"\n                source_code: \"contract Quoter is IQuoter { address public immutable factory; constructor(address _factory) { factory = _factory; } function quoteExactInputSingle(QuoteExactInputSingleParams memory params) public view override returns (uint256 amountReceived, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate) { /* implementation */ } }\"\n            }\n        ]\n    }\n}\n\ntest GenerateScriptTest {\n    functions [GenerateScript]\n    args {\n        group_operations [\n            \"wrap 0.75 ETH to WETH by calling wrap() function\",\n            \"quote swap of 0.75 WETH to USDC using Uniswap V3 Quoter with 0.3% fee (3000)\"\n        ]\n        extracted_infos [\n            {\n                address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"\n                interface_name: \"IWETH\"\n                functions: [\n                    {\n                        signature: \"wrap()\"\n                        abi: \"{\\\"name\\\":\\\"wrap\\\",\\\"type\\\":\\\"function\\\",\\\"stateMutability\\\":\\\"payable\\\",\\\"inputs\\\":[],\\\"outputs\\\":[]}\"\n                    }\n                ]\n                storages: []\n                events: []\n            },\n            {\n                address: \"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6\"\n                interface_name: \"IQuoter\"\n                functions: [\n                    {\n                        signature: \"quoteExactInputSingle(QuoteExactInputSingleParams)\"\n                        abi: \"{\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"quoteExactInputSingle\\\",\\\"inputs\\\":[{\\\"name\\\":\\\"params\\\",\\\"type\\\":\\\"tuple\\\",\\\"internalType\\\":\\\"struct IQuoter.QuoteExactInputSingleParams\\\",\\\"components\\\":[{\\\"name\\\":\\\"tokenIn\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"tokenOut\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"amountIn\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"fee\\\",\\\"type\\\":\\\"uint24\\\"},{\\\"name\\\":\\\"sqrtPriceLimitX96\\\",\\\"type\\\":\\\"uint160\\\"}]}],\\\"outputs\\\":[{\\\"name\\\":\\\"amountReceived\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"sqrtPriceX96After\\\",\\\"type\\\":\\\"uint160\\\"},{\\\"name\\\":\\\"initializedTicksCrossed\\\",\\\"type\\\":\\\"uint32\\\"},{\\\"name\\\":\\\"gasEstimate\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"stateMutability\\\":\\\"view\\\"}\"\n                    }\n                ]\n                storages: []\n                events: []\n            }\n        ]\n    }\n}\n".to_string());

        m.insert("forge_transactions.baml".to_string(), "// Types for forge script transaction generation\n\nclass Parameter {\n  name string @description(\"Parameter name (e.g., 'to', 'amount')\")\n  param_type string @description(\"Solidity type (e.g., 'address', 'uint256')\")\n  value string @description(\"The value - can be literal, reference like 'TOKEN_ADDRESS', 'msg.sender', 'block.timestamp', etc.\")\n}\n\nclass Operation {\n  contract_address string @description(\"Contract address (empty string for deployments)\")\n  contract_name string? @description(\"Contract name for deployments (e.g., 'SimpleToken')\")\n  abi string @description(\"JSON ABI of the contract\")\n  function_name string @description(\"Function name to call (or 'constructor' for deployments)\")\n  parameters Parameter[] @description(\"Function parameters\")\n  eth_value string? @description(\"ETH value in wei for payable functions (e.g., '10000000000000000000' for 10 ETH)\")\n}\n\nenum InterfaceSource {\n  ForgeStd\n  Inline\n}\n\nclass FunctionSignature {\n  name string @description(\"Function name\")\n  signature string @description(\"Full function signature with types\")\n}\n\nclass InterfaceDefinition {\n  name string @description(\"Interface name (e.g., 'IERC20', 'IUniswapV2Router02')\")\n  functions FunctionSignature[] @description(\"Function signatures in the interface\")\n  source InterfaceSource? @description(\"Whether from forge-std or needs inline definition\")\n  solidity_code string? @description(\"Full Solidity interface code (required for Inline source)\")\n}\n\nclass TransactionCall {\n  solidity_code string @description(\"The Solidity code for this transaction call\")\n  description string @description(\"Comment describing what this call does\")\n}\n\nclass GeneratedScript {\n  transaction_calls TransactionCall[] @description(\"List of transaction calls in order\")\n  interfaces_needed InterfaceDefinition[] @description(\"Interfaces that need to be defined/imported\")\n}\n\n// Main function: Generate Solidity transaction calls from structured operations\nfunction GenerateTransactionCalls(\n  operations: Operation[],\n  available_interfaces: InterfaceDefinition[],\n  deployed_addresses: map<string, string>,\n) -> GeneratedScript {\n  client CustomHaiku\n  prompt #\"\n    You are a Solidity code generator. Generate transaction calls for a Forge script from structured operations.\n\n    Operations to perform: {{ operations }}\n    Available Interfaces: {{ available_interfaces }}\n    Deployed Contract References: {{ deployed_addresses }}\n\n    For each operation:\n    1. Analyze the ABI to understand the function signature and parameters\n    2. Generate clean, correct Solidity code for the call\n    3. If it's a deployment (empty contract_address), use: ContractName varName = new ContractName(args);\n    4. If it's a contract call, cast to the appropriate interface and call the function\n    5. Handle parameter values:\n       - If value matches a key in deployed_addresses, use that reference\n       - If value is \"msg.sender\", use msg.sender directly\n       - If value is \"block.timestamp\", use block.timestamp (add +300 for deadlines)\n       - Otherwise, treat as a literal value\n    6. For payable functions with eth_value, add {value: X} before parameters\n\n    Return structured output with:\n    - transaction_calls: Array of calls with solidity_code and description\n    - interfaces_needed: Simply return the available_interfaces provided (they are already prepared)\n\n    Example transaction call:\n    ```solidity\n    IERC20 token = IERC20(0x1234...);\n    token.approve(address(router), 1000000 ether);\n    ```\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest GenerateTransactionCallsTest {\n  functions [GenerateTransactionCalls]\n  args {\n    operations [\n      {\n        contract_address \"\"\n        contract_name \"SimpleToken\"\n        abi \"[{\\\"type\\\":\\\"constructor\\\",\\\"inputs\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"symbol\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"initialSupply\\\",\\\"type\\\":\\\"uint256\\\"}]}]\"\n        function_name \"constructor\"\n        parameters [\n          {\n            name \"name\"\n            param_type \"string\"\n            value \"AomiCoin\"\n          },\n          {\n            name \"symbol\"\n            param_type \"string\"\n            value \"AOM\"\n          },\n          {\n            name \"initialSupply\"\n            param_type \"uint256\"\n            value \"1000000000000000000000000\"\n          }\n        ]\n      },\n      {\n        contract_address \"TOKEN_ADDRESS\"\n        abi \"[{\\\"name\\\":\\\"approve\\\",\\\"type\\\":\\\"function\\\",\\\"inputs\\\":[{\\\"name\\\":\\\"spender\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"amount\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"outputs\\\":[{\\\"type\\\":\\\"bool\\\"}]}]\"\n        function_name \"approve\"\n        parameters [\n          {\n            name \"spender\"\n            param_type \"address\"\n            value \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\"\n          },\n          {\n            name \"amount\"\n            param_type \"uint256\"\n            value \"1000000000000000000000000\"\n          }\n        ]\n      }\n    ]\n    available_interfaces [\n      {\n        name \"IERC20\"\n        functions [\n          {\n            name \"approve\"\n            signature \"approve(address,uint256)\"\n          }\n        ]\n        source ForgeStd\n      }\n    ]\n    deployed_addresses {\n      TOKEN_ADDRESS: \"token\"\n    }\n  }\n}\n".to_string());

        m.insert("generate_conversation_summary.baml".to_string(), "// Data model for a chat message\nclass ChatMessage {\n  role string // \"user\" or \"assistant\"\n  content string\n}\n\n// Data model for conversation summary\nclass ConversationSummary {\n  // High-level topic or goal of the conversation (e.g., \"Token swap on Uniswap\", \"NFT minting on Base\")\n  title string\n\n  // Specific details about what was discussed (e.g., \"100 USDC to ETH\", \"deploying on Arbitrum\")\n  key_details string[]\n\n  // Current state: where did the user leave off? What were they trying to accomplish?\n  current_state string\n\n  // A natural language summary to present to the user (1-2 sentences)\n  user_friendly_summary string\n}\n\n// Data model for session title\nclass SessionTitle {\n  // Concise title for the conversation (3-6 words, e.g., \"ETH to USDC Swap\", \"Deploy ERC20 on Base\")\n  title string\n}\n\n// Function to generate a blockchain conversation summary from message history\nfunction GenerateConversationSummary(messages: ChatMessage[]) -> ConversationSummary {\n  client \"anthropic/claude-3-5-haiku-20241022\"\n  prompt #\"\n    You are summarizing a user's previous conversation about blockchain operations.\n    This could involve any blockchain network (Ethereum, Base, Arbitrum, Optimism, etc.) and\n    various operations like: token swaps, transfers, contract interactions, deployments,\n    transaction analysis, balance checks, NFT operations, etc.\n\n    Previous conversation:\n    {% for msg in messages %}\n    {{ msg.role }}: {{ msg.content }}\n    {% endfor %}\n\n    Analyze this conversation and extract:\n    1. The main topic or goal (what blockchain operation were they discussing?)\n    2. Specific key details (networks, tokens, amounts, addresses, contract names, etc.)\n    3. The current state - where did they leave off? What were they trying to accomplish?\n    4. A friendly, specific summary to greet them with (mention concrete details like network names, token amounts, etc.)\n\n    Be specific and concrete. Include:\n    - Blockchain networks if mentioned (e.g., \"on Base\", \"on Arbitrum\")\n    - Token names and amounts (e.g., \"100 USDC\", \"0.5 ETH\")\n    - Contract addresses or names if relevant\n    - Specific operations (swap, deploy, transfer, mint, etc.)\n\n    Don't be vague - provide actionable context so the user knows exactly what they were working on.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Test with a sample token swap conversation\ntest test_swap_conversation {\n  functions [GenerateConversationSummary]\n  args {\n    messages [\n      {role: \"user\", content: \"How do I swap tokens on Base?\"},\n      {role: \"assistant\", content: \"You can swap tokens on Base using Uniswap V3. What tokens would you like to swap?\"},\n      {role: \"user\", content: \"I want to swap 100 USDC for ETH\"},\n      {role: \"assistant\", content: \"I can help you with that swap on Base network. Let me check the current rates...\"}\n    ]\n  }\n}\n\n// Test with contract deployment conversation\ntest test_contract_deployment {\n  functions [GenerateConversationSummary]\n  args {\n    messages [\n      {role: \"user\", content: \"I need to deploy an ERC20 token on Arbitrum\"},\n      {role: \"assistant\", content: \"I can help you deploy an ERC20 token contract. What should the token name and symbol be?\"},\n      {role: \"user\", content: \"Name: MyToken, Symbol: MTK, supply: 1000000\"}\n    ]\n  }\n}\n\n// Function to generate a concise title for an active session\nfunction GenerateTitle(messages: ChatMessage[]) -> SessionTitle {\n  client \"anthropic/claude-3-5-haiku-20241022\"\n  prompt #\"\n    You are generating a concise title for an active conversation about blockchain operations.\n\n    Current conversation:\n    {% for msg in messages %}\n    {{ msg.role }}: {{ msg.content }}\n    {% endfor %}\n\n    Generate a concise, specific title (3-6 words) that captures what this conversation is about.\n\n    Guidelines:\n    - Be specific: mention networks, tokens, or operations if discussed\n    - Keep it short: 3-6 words maximum\n    - Use title case (e.g., \"ETH to USDC Swap on Base\")\n    - Focus on the main action or topic\n    - Examples:\n      * \"ETH to USDC Swap\"\n      * \"Deploy ERC20 on Arbitrum\"\n      * \"NFT Minting Guide\"\n      * \"Check Wallet Balance\"\n      * \"Uniswap V3 Setup\"\n\n    If the conversation is just starting or unclear, use a generic title like:\n    - \"Blockchain Discussion\"\n    - \"Getting Started\"\n    - \"General Questions\"\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Test title generation for swap conversation\ntest test_title_swap {\n  functions [GenerateTitle]\n  args {\n    messages [\n      {role: \"user\", content: \"How do I swap tokens on Base?\"},\n      {role: \"assistant\", content: \"You can swap tokens on Base using Uniswap V3. What tokens would you like to swap?\"},\n      {role: \"user\", content: \"I want to swap 100 USDC for ETH\"}\n    ]\n  }\n}\n\n// Test title generation for deployment\ntest test_title_deployment {\n  functions [GenerateTitle]\n  args {\n    messages [\n      {role: \"user\", content: \"I need to deploy an ERC20 token on Arbitrum\"},\n      {role: \"assistant\", content: \"I can help you deploy an ERC20 token contract.\"}\n    ]\n  }\n}\n".to_string());

        m.insert("generators.baml".to_string(), "// Generator configuration for BAML client code generation\n\ngenerator target {\n    // Native Rust FFI client (no HTTP server needed)\n    output_type \"rust\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    // This creates baml_client/ as a module directory\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed\n    version \"0.217.0\"\n}\n".to_string());

        m.insert("resume.baml".to_string(), "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n".to_string());

        m.insert("types.baml".to_string(), "// Event operation for add/remove semantics\nclass EventOperation {\n  event_signature string @description(\"Full event signature (e.g., 'ValidatorAdded(uint256 indexed chainId,address indexed validator)')\")\n  where string[]? @description(\"Optional filter expressed as ['operator', '#field', 'value'] (e.g., ['=', '#chainId', '325'])\")\n}\n\n// Event handler configuration matching Rust EventHandler\nclass EventHandlerConfig {\n  event_signature string? @description(\"Primary event signature when a single event drives updates. Null when using explicit add/remove operations only.\")\n  select_field string @description(\"Event parameter that represents the value being tracked (e.g., 'validator', 'account')\")\n  return_type string @description(\"Solidity type for the selected field (e.g., 'address', 'uint256')\")\n  add EventOperation? @description(\"Event operation that inserts/updates a value in the tracked set\")\n  remove EventOperation? @description(\"Event operation that removes a value from the tracked set\")\n}".to_string());

        m
    })
}
