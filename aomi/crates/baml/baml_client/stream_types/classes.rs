// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com


//! Generated streaming class types.
//!
//! These types are used during streaming to hold partial results.
//! Field types are already wrapped appropriately (Option, StreamState, etc.)

use baml::BamlDecode;
use crate::baml_client::types;
use super::*;




#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ABIAnalysisResult {



    pub retrievals: Vec<CallableRetrieval>,



    pub summary: Option<String>,



    pub events: Vec<EventInfo>,

}

impl AsRef<ABIAnalysisResult> for ABIAnalysisResult {
    fn as_ref(&self) -> &ABIAnalysisResult {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct AccessControlConfig {



    pub event_signature: Option<String>,



    pub role_names: Option<std::collections::HashMap<String, String>>,



    pub pick_role_members: Option<String>,

}

impl AsRef<AccessControlConfig> for AccessControlConfig {
    fn as_ref(&self) -> &AccessControlConfig {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct AccessControlHandlerConfig {



    #[baml(name = "type")]

    pub r#type: Option<String>,



    pub roleNames: Option<std::collections::HashMap<String, String>>,



    pub pickRoleMembers: Option<String>,



    pub ignoreRelative: Option<bool>,

}

impl AsRef<AccessControlHandlerConfig> for AccessControlHandlerConfig {
    fn as_ref(&self) -> &AccessControlHandlerConfig {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct CallHandlerConfig {



    #[baml(name = "type")]

    pub r#type: Option<String>,



    pub method: Option<String>,



    pub args: Option<Vec<String>>,



    pub ignoreRelative: Option<bool>,



    pub expectRevert: Option<bool>,



    pub address: Option<String>,

}

impl AsRef<CallHandlerConfig> for CallHandlerConfig {
    fn as_ref(&self) -> &CallHandlerConfig {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct CallableRetrieval {



    pub name: Option<String>,



    pub return_type: Option<String>,



    pub function_signature: Option<String>,



    pub requires_parameters: Option<bool>,



    pub parameter_types: Option<Vec<String>>,



    pub notes: Option<String>,

}

impl AsRef<CallableRetrieval> for CallableRetrieval {
    fn as_ref(&self) -> &CallableRetrieval {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ChatMessage {



    pub role: Option<String>,



    pub content: Option<String>,

}

impl AsRef<ChatMessage> for ChatMessage {
    fn as_ref(&self) -> &ChatMessage {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct CodeLine {



    pub line: Option<String>,



    pub import_spec: Option<Import>,



    pub interface: Option<Interface>,

}

impl AsRef<CodeLine> for CodeLine {
    fn as_ref(&self) -> &CodeLine {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ContractAnalysis {



    pub handlers: Vec<FieldHandler>,



    pub patternDetected: Option<String>,



    pub summary: Option<String>,

}

impl AsRef<ContractAnalysis> for ContractAnalysis {
    fn as_ref(&self) -> &ContractAnalysis {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ContractInfo {



    pub description: Option<String>,



    pub address: Option<String>,



    pub abi: Option<String>,



    pub source_code: Option<String>,

}

impl AsRef<ContractInfo> for ContractInfo {
    fn as_ref(&self) -> &ContractInfo {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ConversationSummary {



    pub title: Option<String>,



    pub key_details: Vec<String>,



    pub current_state: Option<String>,



    pub user_friendly_summary: Option<String>,

}

impl AsRef<ConversationSummary> for ConversationSummary {
    fn as_ref(&self) -> &ConversationSummary {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct DynamicArrayHandlerConfig {



    #[baml(name = "type")]

    pub r#type: Option<String>,



    pub slot: Option<String>,



    pub returnType: Option<String>,



    pub ignoreRelative: Option<bool>,

}

impl AsRef<DynamicArrayHandlerConfig> for DynamicArrayHandlerConfig {
    fn as_ref(&self) -> &DynamicArrayHandlerConfig {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Event {



    pub signature: Option<String>,



    pub abi: Option<String>,

}

impl AsRef<Event> for Event {
    fn as_ref(&self) -> &Event {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct EventAction {



    pub field_name: Option<String>,



    pub action_description: Option<String>,



    pub handler: Option<Union2AccessControlConfigOrEventHandlerConfig>,

}

impl AsRef<EventAction> for EventAction {
    fn as_ref(&self) -> &EventAction {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct EventAnalyzeResult {



    pub event_actions: Vec<EventAction>,



    pub detected_constants: Option<std::collections::HashMap<String, String>>,



    pub proxy_pattern: Option<String>,



    pub summary: Option<String>,



    pub warnings: Option<Vec<String>>,

}

impl AsRef<EventAnalyzeResult> for EventAnalyzeResult {
    fn as_ref(&self) -> &EventAnalyzeResult {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct EventHandlerConfig {



    pub event_signature: Option<String>,



    pub select_field: Option<String>,



    pub return_type: Option<String>,



    pub add: Option<EventOperation>,



    pub remove: Option<EventOperation>,

}

impl AsRef<EventHandlerConfig> for EventHandlerConfig {
    fn as_ref(&self) -> &EventHandlerConfig {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct EventInfo {



    pub description: Option<String>,



    pub event_signature: Option<String>,



    pub query_fields: Vec<String>,

}

impl AsRef<EventInfo> for EventInfo {
    fn as_ref(&self) -> &EventInfo {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct EventOperation {



    pub event_signature: Option<String>,



    #[baml(name = "where")]

    pub r#where: Option<Vec<String>>,

}

impl AsRef<EventOperation> for EventOperation {
    fn as_ref(&self) -> &EventOperation {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ExtractedContractInfo {



    pub description: Option<String>,



    pub address: Option<String>,



    pub interface_name: Option<String>,



    pub functions: Vec<Function>,



    pub storages: Vec<Storage>,



    pub events: Vec<Event>,

}

impl AsRef<ExtractedContractInfo> for ExtractedContractInfo {
    fn as_ref(&self) -> &ExtractedContractInfo {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct FieldHandler {



    pub fieldName: Option<String>,



    pub config: Option<Union5AccessControlHandlerConfigOrCallHandlerConfigOrDynamicArrayHandlerConfigOrEventHandlerConfigOrStorageHandlerConfig>,



    pub description: Option<String>,

}

impl AsRef<FieldHandler> for FieldHandler {
    fn as_ref(&self) -> &FieldHandler {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Function {



    pub description: Option<String>,



    pub signature: Option<String>,



    pub abi: Option<String>,



    pub body: Option<String>,



    pub arguments: Option<String>,

}

impl AsRef<Function> for Function {
    fn as_ref(&self) -> &Function {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct FunctionSignature {



    pub name: Option<String>,



    pub signature: Option<String>,

}

impl AsRef<FunctionSignature> for FunctionSignature {
    fn as_ref(&self) -> &FunctionSignature {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct GeneratedScript {



    pub transaction_calls: Vec<TransactionCall>,



    pub interfaces_needed: Vec<InterfaceDefinition>,

}

impl AsRef<GeneratedScript> for GeneratedScript {
    fn as_ref(&self) -> &GeneratedScript {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Import {



    pub interface_name: Option<String>,



    pub source: Option<String>,

}

impl AsRef<Import> for Import {
    fn as_ref(&self) -> &Import {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Interface {



    pub name: Option<String>,



    pub solidity_code: Option<String>,

}

impl AsRef<Interface> for Interface {
    fn as_ref(&self) -> &Interface {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct InterfaceDefinition {



    pub name: Option<String>,



    pub functions: Vec<FunctionSignature>,



    pub source: Option<types::InterfaceSource>,



    pub solidity_code: Option<String>,

}

impl AsRef<InterfaceDefinition> for InterfaceDefinition {
    fn as_ref(&self) -> &InterfaceDefinition {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct LayoutAnalysisResult {



    pub contract_name: Option<String>,



    pub solidity_version: Option<String>,



    pub inheritance: Option<String>,



    pub slots: Vec<SlotInfo>,



    pub detected_constants: Option<std::collections::HashMap<String, String>>,



    pub proxy_pattern: Option<String>,



    pub summary: Option<String>,



    pub warnings: Option<Vec<String>>,

}

impl AsRef<LayoutAnalysisResult> for LayoutAnalysisResult {
    fn as_ref(&self) -> &LayoutAnalysisResult {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Operation {



    pub contract_address: Option<String>,



    pub contract_name: Option<String>,



    pub abi: Option<String>,



    pub function_name: Option<String>,



    pub parameters: Vec<Parameter>,



    pub eth_value: Option<String>,

}

impl AsRef<Operation> for Operation {
    fn as_ref(&self) -> &Operation {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Parameter {



    pub name: Option<String>,



    pub param_type: Option<String>,



    pub value: Option<String>,

}

impl AsRef<Parameter> for Parameter {
    fn as_ref(&self) -> &Parameter {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Resume {



    pub name: Option<String>,



    pub email: Option<String>,



    pub experience: Vec<String>,



    pub skills: Vec<String>,

}

impl AsRef<Resume> for Resume {
    fn as_ref(&self) -> &Resume {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct ScriptBlock {



    pub codelines: Vec<CodeLine>,

}

impl AsRef<ScriptBlock> for ScriptBlock {
    fn as_ref(&self) -> &ScriptBlock {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct SessionTitle {



    pub title: Option<String>,

}

impl AsRef<SessionTitle> for SessionTitle {
    fn as_ref(&self) -> &SessionTitle {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct SlotInfo {



    pub name: Option<String>,



    #[baml(name = "type")]

    pub r#type: Option<String>,



    pub base_slot: Option<String>,



    pub offset: Option<i64>,



    pub getter_signature: Option<String>,



    pub notes: Option<String>,

}

impl AsRef<SlotInfo> for SlotInfo {
    fn as_ref(&self) -> &SlotInfo {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct Storage {



    pub description: Option<String>,



    pub declaration: Option<String>,



    pub index: Option<i64>,

}

impl AsRef<Storage> for Storage {
    fn as_ref(&self) -> &Storage {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct StorageHandlerConfig {



    #[baml(name = "type")]

    pub r#type: Option<String>,



    pub slot: Option<String>,



    pub offset: Option<i64>,



    pub returnType: Option<String>,



    pub ignoreRelative: Option<bool>,

}

impl AsRef<StorageHandlerConfig> for StorageHandlerConfig {
    fn as_ref(&self) -> &StorageHandlerConfig {
        self
    }
}



#[derive(Debug, Clone, Default, BamlDecode)]
pub struct TransactionCall {



    pub solidity_code: Option<String>,



    pub description: Option<String>,

}

impl AsRef<TransactionCall> for TransactionCall {
    fn as_ref(&self) -> &TransactionCall {
        self
    }
}

