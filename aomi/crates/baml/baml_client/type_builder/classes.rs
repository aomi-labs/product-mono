// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class builder wrappers for type-safe field access.

/// Wrapper for the `ABIAnalysisResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ABIAnalysisResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl ABIAnalysisResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "ABIAnalysisResult is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `retrievals` field builder.
    pub fn property_retrievals(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("retrievals")
            .expect("ABIAnalysisResult.retrievals is statically defined in .baml and should always be present")
    }

    /// Access the `summary` field builder.
    pub fn property_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("summary").expect(
            "ABIAnalysisResult.summary is statically defined in .baml and should always be present",
        )
    }

    /// Access the `events` field builder.
    pub fn property_events(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("events").expect(
            "ABIAnalysisResult.events is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `AccessControlConfig` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AccessControlConfigClassBuilder {
    inner: baml::ClassBuilder,
}

impl AccessControlConfigClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "AccessControlConfig is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `event_signature` field builder.
    pub fn property_event_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_signature")
            .expect("AccessControlConfig.event_signature is statically defined in .baml and should always be present")
    }

    /// Access the `role_names` field builder.
    pub fn property_role_names(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("role_names")
            .expect("AccessControlConfig.role_names is statically defined in .baml and should always be present")
    }

    /// Access the `pick_role_members` field builder.
    pub fn property_pick_role_members(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pick_role_members")
            .expect("AccessControlConfig.pick_role_members is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `AccessControlHandlerConfig` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AccessControlHandlerConfigClassBuilder {
    inner: baml::ClassBuilder,
}

impl AccessControlHandlerConfigClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AccessControlHandlerConfig is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `r#type` field builder.
    pub fn property_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("type")
            .expect("AccessControlHandlerConfig.type is statically defined in .baml and should always be present")
    }

    /// Access the `roleNames` field builder.
    pub fn property_roleNames(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("roleNames")
            .expect("AccessControlHandlerConfig.roleNames is statically defined in .baml and should always be present")
    }

    /// Access the `pickRoleMembers` field builder.
    pub fn property_pickRoleMembers(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pickRoleMembers")
            .expect("AccessControlHandlerConfig.pickRoleMembers is statically defined in .baml and should always be present")
    }

    /// Access the `ignoreRelative` field builder.
    pub fn property_ignoreRelative(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("ignoreRelative")
            .expect("AccessControlHandlerConfig.ignoreRelative is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `CallHandlerConfig` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct CallHandlerConfigClassBuilder {
    inner: baml::ClassBuilder,
}

impl CallHandlerConfigClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "CallHandlerConfig is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `r#type` field builder.
    pub fn property_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("type").expect(
            "CallHandlerConfig.type is statically defined in .baml and should always be present",
        )
    }

    /// Access the `method` field builder.
    pub fn property_method(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("method").expect(
            "CallHandlerConfig.method is statically defined in .baml and should always be present",
        )
    }

    /// Access the `args` field builder.
    pub fn property_args(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("args").expect(
            "CallHandlerConfig.args is statically defined in .baml and should always be present",
        )
    }

    /// Access the `ignoreRelative` field builder.
    pub fn property_ignoreRelative(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("ignoreRelative")
            .expect("CallHandlerConfig.ignoreRelative is statically defined in .baml and should always be present")
    }

    /// Access the `expectRevert` field builder.
    pub fn property_expectRevert(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("expectRevert")
            .expect("CallHandlerConfig.expectRevert is statically defined in .baml and should always be present")
    }

    /// Access the `address` field builder.
    pub fn property_address(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("address").expect(
            "CallHandlerConfig.address is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `CallableRetrieval` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct CallableRetrievalClassBuilder {
    inner: baml::ClassBuilder,
}

impl CallableRetrievalClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "CallableRetrieval is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name").expect(
            "CallableRetrieval.name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `return_type` field builder.
    pub fn property_return_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("return_type")
            .expect("CallableRetrieval.return_type is statically defined in .baml and should always be present")
    }

    /// Access the `function_signature` field builder.
    pub fn property_function_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("function_signature")
            .expect("CallableRetrieval.function_signature is statically defined in .baml and should always be present")
    }

    /// Access the `requires_parameters` field builder.
    pub fn property_requires_parameters(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("requires_parameters")
            .expect("CallableRetrieval.requires_parameters is statically defined in .baml and should always be present")
    }

    /// Access the `parameter_types` field builder.
    pub fn property_parameter_types(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("parameter_types")
            .expect("CallableRetrieval.parameter_types is statically defined in .baml and should always be present")
    }

    /// Access the `notes` field builder.
    pub fn property_notes(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("notes").expect(
            "CallableRetrieval.notes is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ChatMessage` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ChatMessageClassBuilder {
    inner: baml::ClassBuilder,
}

impl ChatMessageClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("ChatMessage is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `role` field builder.
    pub fn property_role(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("role")
            .expect("ChatMessage.role is statically defined in .baml and should always be present")
    }

    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content").expect(
            "ChatMessage.content is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `CodeLine` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct CodeLineClassBuilder {
    inner: baml::ClassBuilder,
}

impl CodeLineClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("CodeLine is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `line` field builder.
    pub fn property_line(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("line")
            .expect("CodeLine.line is statically defined in .baml and should always be present")
    }

    /// Access the `import_spec` field builder.
    pub fn property_import_spec(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("import_spec").expect(
            "CodeLine.import_spec is statically defined in .baml and should always be present",
        )
    }

    /// Access the `interface` field builder.
    pub fn property_interface(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("interface").expect(
            "CodeLine.interface is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ContractAnalysis` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ContractAnalysisClassBuilder {
    inner: baml::ClassBuilder,
}

impl ContractAnalysisClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("ContractAnalysis is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `handlers` field builder.
    pub fn property_handlers(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("handlers").expect(
            "ContractAnalysis.handlers is statically defined in .baml and should always be present",
        )
    }

    /// Access the `patternDetected` field builder.
    pub fn property_patternDetected(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("patternDetected")
            .expect("ContractAnalysis.patternDetected is statically defined in .baml and should always be present")
    }

    /// Access the `summary` field builder.
    pub fn property_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("summary").expect(
            "ContractAnalysis.summary is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ContractInfo` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ContractInfoClassBuilder {
    inner: baml::ClassBuilder,
}

impl ContractInfoClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("ContractInfo is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description").expect(
            "ContractInfo.description is statically defined in .baml and should always be present",
        )
    }

    /// Access the `address` field builder.
    pub fn property_address(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("address").expect(
            "ContractInfo.address is statically defined in .baml and should always be present",
        )
    }

    /// Access the `abi` field builder.
    pub fn property_abi(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("abi")
            .expect("ContractInfo.abi is statically defined in .baml and should always be present")
    }

    /// Access the `source_code` field builder.
    pub fn property_source_code(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("source_code").expect(
            "ContractInfo.source_code is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ConversationSummary` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConversationSummaryClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConversationSummaryClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "ConversationSummary is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `title` field builder.
    pub fn property_title(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("title").expect(
            "ConversationSummary.title is statically defined in .baml and should always be present",
        )
    }

    /// Access the `key_details` field builder.
    pub fn property_key_details(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("key_details")
            .expect("ConversationSummary.key_details is statically defined in .baml and should always be present")
    }

    /// Access the `current_state` field builder.
    pub fn property_current_state(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("current_state")
            .expect("ConversationSummary.current_state is statically defined in .baml and should always be present")
    }

    /// Access the `user_friendly_summary` field builder.
    pub fn property_user_friendly_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("user_friendly_summary")
            .expect("ConversationSummary.user_friendly_summary is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `DynamicArrayHandlerConfig` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct DynamicArrayHandlerConfigClassBuilder {
    inner: baml::ClassBuilder,
}

impl DynamicArrayHandlerConfigClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("DynamicArrayHandlerConfig is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `r#type` field builder.
    pub fn property_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("type")
            .expect("DynamicArrayHandlerConfig.type is statically defined in .baml and should always be present")
    }

    /// Access the `slot` field builder.
    pub fn property_slot(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("slot")
            .expect("DynamicArrayHandlerConfig.slot is statically defined in .baml and should always be present")
    }

    /// Access the `returnType` field builder.
    pub fn property_returnType(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("returnType")
            .expect("DynamicArrayHandlerConfig.returnType is statically defined in .baml and should always be present")
    }

    /// Access the `ignoreRelative` field builder.
    pub fn property_ignoreRelative(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("ignoreRelative")
            .expect("DynamicArrayHandlerConfig.ignoreRelative is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Event` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Event is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `signature` field builder.
    pub fn property_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("signature")
            .expect("Event.signature is statically defined in .baml and should always be present")
    }

    /// Access the `abi` field builder.
    pub fn property_abi(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("abi")
            .expect("Event.abi is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `EventAction` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventActionClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventActionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("EventAction is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `field_name` field builder.
    pub fn property_field_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("field_name").expect(
            "EventAction.field_name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `action_description` field builder.
    pub fn property_action_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("action_description")
            .expect("EventAction.action_description is statically defined in .baml and should always be present")
    }

    /// Access the `handler` field builder.
    pub fn property_handler(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("handler").expect(
            "EventAction.handler is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `EventAnalyzeResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventAnalyzeResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventAnalyzeResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "EventAnalyzeResult is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `event_actions` field builder.
    pub fn property_event_actions(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_actions")
            .expect("EventAnalyzeResult.event_actions is statically defined in .baml and should always be present")
    }

    /// Access the `detected_constants` field builder.
    pub fn property_detected_constants(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("detected_constants")
            .expect("EventAnalyzeResult.detected_constants is statically defined in .baml and should always be present")
    }

    /// Access the `proxy_pattern` field builder.
    pub fn property_proxy_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("proxy_pattern")
            .expect("EventAnalyzeResult.proxy_pattern is statically defined in .baml and should always be present")
    }

    /// Access the `summary` field builder.
    pub fn property_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("summary")
            .expect("EventAnalyzeResult.summary is statically defined in .baml and should always be present")
    }

    /// Access the `warnings` field builder.
    pub fn property_warnings(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("warnings")
            .expect("EventAnalyzeResult.warnings is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `EventHandlerConfig` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventHandlerConfigClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventHandlerConfigClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "EventHandlerConfig is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `event_signature` field builder.
    pub fn property_event_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_signature")
            .expect("EventHandlerConfig.event_signature is statically defined in .baml and should always be present")
    }

    /// Access the `select_field` field builder.
    pub fn property_select_field(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("select_field")
            .expect("EventHandlerConfig.select_field is statically defined in .baml and should always be present")
    }

    /// Access the `return_type` field builder.
    pub fn property_return_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("return_type")
            .expect("EventHandlerConfig.return_type is statically defined in .baml and should always be present")
    }

    /// Access the `add` field builder.
    pub fn property_add(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("add").expect(
            "EventHandlerConfig.add is statically defined in .baml and should always be present",
        )
    }

    /// Access the `remove` field builder.
    pub fn property_remove(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("remove").expect(
            "EventHandlerConfig.remove is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `EventInfo` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventInfoClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventInfoClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("EventInfo is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description").expect(
            "EventInfo.description is statically defined in .baml and should always be present",
        )
    }

    /// Access the `event_signature` field builder.
    pub fn property_event_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_signature").expect(
            "EventInfo.event_signature is statically defined in .baml and should always be present",
        )
    }

    /// Access the `query_fields` field builder.
    pub fn property_query_fields(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query_fields").expect(
            "EventInfo.query_fields is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `EventOperation` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventOperationClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventOperationClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("EventOperation is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `event_signature` field builder.
    pub fn property_event_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_signature")
            .expect("EventOperation.event_signature is statically defined in .baml and should always be present")
    }

    /// Access the `r#where` field builder.
    pub fn property_where(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("where").expect(
            "EventOperation.where is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ExtractedContractInfo` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ExtractedContractInfoClassBuilder {
    inner: baml::ClassBuilder,
}

impl ExtractedContractInfoClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "ExtractedContractInfo is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("ExtractedContractInfo.description is statically defined in .baml and should always be present")
    }

    /// Access the `address` field builder.
    pub fn property_address(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("address")
            .expect("ExtractedContractInfo.address is statically defined in .baml and should always be present")
    }

    /// Access the `interface_name` field builder.
    pub fn property_interface_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("interface_name")
            .expect("ExtractedContractInfo.interface_name is statically defined in .baml and should always be present")
    }

    /// Access the `functions` field builder.
    pub fn property_functions(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("functions")
            .expect("ExtractedContractInfo.functions is statically defined in .baml and should always be present")
    }

    /// Access the `storages` field builder.
    pub fn property_storages(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("storages")
            .expect("ExtractedContractInfo.storages is statically defined in .baml and should always be present")
    }

    /// Access the `events` field builder.
    pub fn property_events(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("events")
            .expect("ExtractedContractInfo.events is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `FieldHandler` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct FieldHandlerClassBuilder {
    inner: baml::ClassBuilder,
}

impl FieldHandlerClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("FieldHandler is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `fieldName` field builder.
    pub fn property_fieldName(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("fieldName").expect(
            "FieldHandler.fieldName is statically defined in .baml and should always be present",
        )
    }

    /// Access the `config` field builder.
    pub fn property_config(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("config").expect(
            "FieldHandler.config is statically defined in .baml and should always be present",
        )
    }

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description").expect(
            "FieldHandler.description is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `Function` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct FunctionClassBuilder {
    inner: baml::ClassBuilder,
}

impl FunctionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Function is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description").expect(
            "Function.description is statically defined in .baml and should always be present",
        )
    }

    /// Access the `signature` field builder.
    pub fn property_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("signature").expect(
            "Function.signature is statically defined in .baml and should always be present",
        )
    }

    /// Access the `abi` field builder.
    pub fn property_abi(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("abi")
            .expect("Function.abi is statically defined in .baml and should always be present")
    }

    /// Access the `body` field builder.
    pub fn property_body(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("body")
            .expect("Function.body is statically defined in .baml and should always be present")
    }

    /// Access the `arguments` field builder.
    pub fn property_arguments(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("arguments").expect(
            "Function.arguments is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `FunctionSignature` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct FunctionSignatureClassBuilder {
    inner: baml::ClassBuilder,
}

impl FunctionSignatureClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "FunctionSignature is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name").expect(
            "FunctionSignature.name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `signature` field builder.
    pub fn property_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("signature")
            .expect("FunctionSignature.signature is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `GeneratedScript` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct GeneratedScriptClassBuilder {
    inner: baml::ClassBuilder,
}

impl GeneratedScriptClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("GeneratedScript is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `transaction_calls` field builder.
    pub fn property_transaction_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("transaction_calls")
            .expect("GeneratedScript.transaction_calls is statically defined in .baml and should always be present")
    }

    /// Access the `interfaces_needed` field builder.
    pub fn property_interfaces_needed(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("interfaces_needed")
            .expect("GeneratedScript.interfaces_needed is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Import` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ImportClassBuilder {
    inner: baml::ClassBuilder,
}

impl ImportClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Import is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `interface_name` field builder.
    pub fn property_interface_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("interface_name").expect(
            "Import.interface_name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `source` field builder.
    pub fn property_source(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("source")
            .expect("Import.source is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Interface` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct InterfaceClassBuilder {
    inner: baml::ClassBuilder,
}

impl InterfaceClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Interface is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("name")
            .expect("Interface.name is statically defined in .baml and should always be present")
    }

    /// Access the `solidity_code` field builder.
    pub fn property_solidity_code(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("solidity_code").expect(
            "Interface.solidity_code is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `InterfaceDefinition` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct InterfaceDefinitionClassBuilder {
    inner: baml::ClassBuilder,
}

impl InterfaceDefinitionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "InterfaceDefinition is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name").expect(
            "InterfaceDefinition.name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `functions` field builder.
    pub fn property_functions(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("functions")
            .expect("InterfaceDefinition.functions is statically defined in .baml and should always be present")
    }

    /// Access the `source` field builder.
    pub fn property_source(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("source")
            .expect("InterfaceDefinition.source is statically defined in .baml and should always be present")
    }

    /// Access the `solidity_code` field builder.
    pub fn property_solidity_code(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("solidity_code")
            .expect("InterfaceDefinition.solidity_code is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `LayoutAnalysisResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct LayoutAnalysisResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl LayoutAnalysisResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "LayoutAnalysisResult is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `contract_name` field builder.
    pub fn property_contract_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("contract_name")
            .expect("LayoutAnalysisResult.contract_name is statically defined in .baml and should always be present")
    }

    /// Access the `solidity_version` field builder.
    pub fn property_solidity_version(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("solidity_version")
            .expect("LayoutAnalysisResult.solidity_version is statically defined in .baml and should always be present")
    }

    /// Access the `inheritance` field builder.
    pub fn property_inheritance(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("inheritance")
            .expect("LayoutAnalysisResult.inheritance is statically defined in .baml and should always be present")
    }

    /// Access the `slots` field builder.
    pub fn property_slots(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("slots")
            .expect("LayoutAnalysisResult.slots is statically defined in .baml and should always be present")
    }

    /// Access the `detected_constants` field builder.
    pub fn property_detected_constants(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("detected_constants")
            .expect("LayoutAnalysisResult.detected_constants is statically defined in .baml and should always be present")
    }

    /// Access the `proxy_pattern` field builder.
    pub fn property_proxy_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("proxy_pattern")
            .expect("LayoutAnalysisResult.proxy_pattern is statically defined in .baml and should always be present")
    }

    /// Access the `summary` field builder.
    pub fn property_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("summary")
            .expect("LayoutAnalysisResult.summary is statically defined in .baml and should always be present")
    }

    /// Access the `warnings` field builder.
    pub fn property_warnings(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("warnings")
            .expect("LayoutAnalysisResult.warnings is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Operation` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct OperationClassBuilder {
    inner: baml::ClassBuilder,
}

impl OperationClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Operation is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `contract_address` field builder.
    pub fn property_contract_address(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("contract_address")
            .expect("Operation.contract_address is statically defined in .baml and should always be present")
    }

    /// Access the `contract_name` field builder.
    pub fn property_contract_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("contract_name").expect(
            "Operation.contract_name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `abi` field builder.
    pub fn property_abi(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("abi")
            .expect("Operation.abi is statically defined in .baml and should always be present")
    }

    /// Access the `function_name` field builder.
    pub fn property_function_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("function_name").expect(
            "Operation.function_name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `parameters` field builder.
    pub fn property_parameters(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("parameters").expect(
            "Operation.parameters is statically defined in .baml and should always be present",
        )
    }

    /// Access the `eth_value` field builder.
    pub fn property_eth_value(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("eth_value").expect(
            "Operation.eth_value is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `Parameter` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ParameterClassBuilder {
    inner: baml::ClassBuilder,
}

impl ParameterClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Parameter is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("name")
            .expect("Parameter.name is statically defined in .baml and should always be present")
    }

    /// Access the `param_type` field builder.
    pub fn property_param_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("param_type").expect(
            "Parameter.param_type is statically defined in .baml and should always be present",
        )
    }

    /// Access the `value` field builder.
    pub fn property_value(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("value")
            .expect("Parameter.value is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Resume` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResumeClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResumeClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Resume is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("name")
            .expect("Resume.name is statically defined in .baml and should always be present")
    }

    /// Access the `email` field builder.
    pub fn property_email(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("email")
            .expect("Resume.email is statically defined in .baml and should always be present")
    }

    /// Access the `experience` field builder.
    pub fn property_experience(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("experience")
            .expect("Resume.experience is statically defined in .baml and should always be present")
    }

    /// Access the `skills` field builder.
    pub fn property_skills(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("skills")
            .expect("Resume.skills is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `ScriptBlock` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ScriptBlockClassBuilder {
    inner: baml::ClassBuilder,
}

impl ScriptBlockClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("ScriptBlock is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `codelines` field builder.
    pub fn property_codelines(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("codelines").expect(
            "ScriptBlock.codelines is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `SessionTitle` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct SessionTitleClassBuilder {
    inner: baml::ClassBuilder,
}

impl SessionTitleClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("SessionTitle is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `title` field builder.
    pub fn property_title(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("title").expect(
            "SessionTitle.title is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `SlotInfo` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct SlotInfoClassBuilder {
    inner: baml::ClassBuilder,
}

impl SlotInfoClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("SlotInfo is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("name")
            .expect("SlotInfo.name is statically defined in .baml and should always be present")
    }

    /// Access the `r#type` field builder.
    pub fn property_type(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("type")
            .expect("SlotInfo.type is statically defined in .baml and should always be present")
    }

    /// Access the `base_slot` field builder.
    pub fn property_base_slot(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("base_slot").expect(
            "SlotInfo.base_slot is statically defined in .baml and should always be present",
        )
    }

    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("offset")
            .expect("SlotInfo.offset is statically defined in .baml and should always be present")
    }

    /// Access the `getter_signature` field builder.
    pub fn property_getter_signature(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("getter_signature").expect(
            "SlotInfo.getter_signature is statically defined in .baml and should always be present",
        )
    }

    /// Access the `notes` field builder.
    pub fn property_notes(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("notes")
            .expect("SlotInfo.notes is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Storage` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct StorageClassBuilder {
    inner: baml::ClassBuilder,
}

impl StorageClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Storage is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description").expect(
            "Storage.description is statically defined in .baml and should always be present",
        )
    }

    /// Access the `declaration` field builder.
    pub fn property_declaration(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("declaration").expect(
            "Storage.declaration is statically defined in .baml and should always be present",
        )
    }

    /// Access the `index` field builder.
    pub fn property_index(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("index")
            .expect("Storage.index is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `StorageHandlerConfig` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct StorageHandlerConfigClassBuilder {
    inner: baml::ClassBuilder,
}

impl StorageHandlerConfigClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "StorageHandlerConfig is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `r#type` field builder.
    pub fn property_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("type").expect(
            "StorageHandlerConfig.type is statically defined in .baml and should always be present",
        )
    }

    /// Access the `slot` field builder.
    pub fn property_slot(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("slot").expect(
            "StorageHandlerConfig.slot is statically defined in .baml and should always be present",
        )
    }

    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset")
            .expect("StorageHandlerConfig.offset is statically defined in .baml and should always be present")
    }

    /// Access the `returnType` field builder.
    pub fn property_returnType(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("returnType")
            .expect("StorageHandlerConfig.returnType is statically defined in .baml and should always be present")
    }

    /// Access the `ignoreRelative` field builder.
    pub fn property_ignoreRelative(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("ignoreRelative")
            .expect("StorageHandlerConfig.ignoreRelative is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `TransactionCall` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct TransactionCallClassBuilder {
    inner: baml::ClassBuilder,
}

impl TransactionCallClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("TransactionCall is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `solidity_code` field builder.
    pub fn property_solidity_code(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("solidity_code")
            .expect("TransactionCall.solidity_code is statically defined in .baml and should always be present")
    }

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("TransactionCall.description is statically defined in .baml and should always be present")
    }
}
