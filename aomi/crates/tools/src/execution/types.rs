use eyre::Result as EyreResult;
use eyre::WrapErr;
use futures::FutureExt;
use futures::future::BoxFuture;
use serde::{Deserialize, Serialize};
use serde::de::DeserializeOwned;
use serde_json::Value;
use std::collections::HashMap;
use std::future::Future;
use std::sync::{OnceLock, RwLock};

/// Trait for external API tools with associated request and response types
pub trait AomiApiTool: Send + Sync {
    type ApiRequest: Send + Sync + Clone;
    type ApiResponse: Send + Sync + Clone;
    type MultiStepResults: Send + Sync + Clone + DeserializeOwned + Serialize + 'static;
    type Error: std::error::Error + Send + Sync + 'static;

    /// Execute an API call returning a future
    fn call(
        &self,
        request: Self::ApiRequest,
    ) -> impl Future<Output = Result<Self::ApiResponse, Self::Error>> + Send + Sync;

    /// Get the name of this API tool
    fn name(&self) -> &'static str;

    /// Get a description of what this API tool does
    fn description(&self) -> &'static str;

    fn check_input(&self, request: Self::ApiRequest) -> bool;

    /// Get a static topic/description for this tool - defaults to name
    fn static_topic(&self) -> &'static str {
        self.name()
    }
}

// Note: The specific tool implementations (AbiEncoderTool, WalletTransactionTool, TimeTool)
// have been removed since the Rig tools generated by #[rig_tool] macro already implement
// AomiApiTool through the generic implementation below.

// Generic implementation of AomiApiTool for Rig tools
impl<T> AomiApiTool for T
where
    T: rig::tool::Tool + Send + Sync + Clone,
    T::Args: serde::de::DeserializeOwned + Send + Sync + Clone,
    T::Output: serde::Serialize + Send + Sync + Clone,
    T::Error: std::error::Error + Send + Sync + 'static,
{
    type ApiRequest = T::Args;
    type ApiResponse = T::Output;
    type MultiStepResults = ();
    type Error = T::Error;

    fn call(
        &self,
        request: Self::ApiRequest,
    ) -> impl Future<Output = Result<T::Output, T::Error>> + Send + Sync {
        self.call(request)
    }

    fn name(&self) -> &'static str {
        T::NAME
    }

    fn description(&self) -> &'static str {
        // Rig tools don't have a static description method, so we use the name
        T::NAME
    }

    fn check_input(&self, _request: Self::ApiRequest) -> bool {
        // No input validation by default - Rig tools handle their own validation
        true
    }
}

/// Trait object for type-erased API tools
pub trait AnyApiTool: Send + Sync {
    fn call_with_json(&self, payload: Value) -> BoxFuture<'static, EyreResult<Value>>;
    fn validate_json(&self, payload: &Value) -> EyreResult<()>;
    fn tool(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn static_topic(&self) -> &'static str;

    /// Check if this tool returns multiple results over time
    /// When true, the scheduler will use mpsc channel and call `call_with_sender`
    fn multi_steps(&self) -> bool {
        false
    }

    /// Call with sender for multi-step tools
    /// Tool owns the sender and can send multiple results before dropping it
    /// Default implementation wraps single-result call and sends one result
    fn call_with_sender(
        &self,
        payload: Value,
        sender: tokio::sync::mpsc::Sender<EyreResult<Value>>,
    ) -> BoxFuture<'static, EyreResult<()>> {
        let fut = self.call_with_json(payload);

        async move {
            let result = fut.await;
            // Send the single result and drop sender (closes channel)
            let _ = sender.send(result).await;
            Ok(())
        }
        .boxed()
    }

    /// Validate and type-check a multi-step result value.
    /// Default: pass-through.
    fn validate_multi_step_result(&self, value: &Value) -> EyreResult<Value> {
        Ok(value.clone())
    }
}

/// Format tool name for display
/// Converts snake_case to readable format (e.g., "encode_function_call" -> "Encode function call")
/// If not snake_case, splits on capitals (e.g., "MyTool" -> "My tool")
pub fn format_tool_name(name: &str) -> &'static str {
    static CACHE: OnceLock<RwLock<HashMap<String, &'static str>>> = OnceLock::new();
    let cache = CACHE.get_or_init(|| RwLock::new(HashMap::new()));

    if let Ok(guard) = cache.read()
        && let Some(cached) = guard.get(name)
    {
        return cached;
    }

    let words: Vec<String> =
        if name.contains('_') && name.chars().all(|c| c.is_lowercase() || c == '_') {
            name.split('_')
                .filter(|s| !s.is_empty())
                .map(|s| s.to_string())
                .collect()
        } else {
            let mut words = Vec::new();
            let mut word = String::new();
            for (i, ch) in name.chars().enumerate() {
                if ch.is_uppercase() && i > 0 && !word.is_empty() {
                    words.push(word);
                    word = String::new();
                }
                word.push(ch);
            }
            if !word.is_empty() {
                words.push(word);
            }
            words
        };

    let formatted = words
        .iter()
        .enumerate()
        .map(|(i, w)| {
            let w = w.to_lowercase();
            if i == 0 {
                let mut chars = w.chars();
                chars.next().map_or_else(String::new, |c| {
                    c.to_uppercase().next().unwrap_or(c).to_string() + &chars.collect::<String>()
                })
            } else {
                w
            }
        })
        .collect::<Vec<_>>()
        .join(" ");

    let static_str = Box::leak(formatted.into_boxed_str());
    cache.write().unwrap().insert(name.to_string(), static_str);
    static_str
}

/// Implement AnyApiTool for any ExternalApiTool
impl<T> AnyApiTool for T
where
    T: AomiApiTool + Clone + 'static,
    T::ApiRequest: for<'de> Deserialize<'de> + Send + 'static,
    T::ApiResponse: Serialize + Send + 'static,
{
    fn call_with_json(&self, payload: Value) -> BoxFuture<'static, EyreResult<Value>> {
        let tool = self.clone();
        async move {
            // 1. Deserialize JSON to T::ApiRequest
            let request: T::ApiRequest =
                serde_json::from_value(payload).wrap_err("Failed to deserialize request")?;

            // 2. Validate input using the tool's validation
            if !tool.check_input(request.clone()) {
                return Err(eyre::eyre!("Request validation failed"));
            }

            // 3. Call the actual API
            let response = tool
                .call(request)
                .await
                .map_err(|e| eyre::eyre!("Tool call failed: {}", e))?;

            // 4. Serialize response back to JSON
            serde_json::to_value(response).wrap_err("Failed to serialize response")
        }
        .boxed()
    }

    fn validate_json(&self, payload: &Value) -> EyreResult<()> {
        // Try to deserialize to check if JSON structure is valid
        let request: T::ApiRequest =
            serde_json::from_value(payload.clone()).wrap_err("Failed to deserialize request")?;
        if self.check_input(request) {
            Ok(())
        } else {
            Err(eyre::eyre!("Request validation failed"))
        }
    }

    fn tool(&self) -> &'static str {
        <T as AomiApiTool>::name(self)
    }

    fn description(&self) -> &'static str {
        <T as AomiApiTool>::description(self)
    }

    fn static_topic(&self) -> &'static str {
        let original = <T as AomiApiTool>::static_topic(self);
        format_tool_name(original)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::time::{GetCurrentTime, GetCurrentTimeParameters};
    use eyre::Result;
    use rig::tool::Tool as RigTool;

    async fn call_any_api<T>(tool: &T, request: T::ApiRequest) -> Result<T::ApiResponse>
    where
        T: AomiApiTool,
        T::Error: std::fmt::Display,
    {
        let response = AomiApiTool::call(tool, request).await?;
        Ok(response)
    }

    #[tokio::test]
    async fn trait_dispatch_invokes_underlying_tool() {
        let tool = GetCurrentTime;
        let args = GetCurrentTimeParameters {
            topic: "Check server clock for scheduling".to_string(),
        };

        let response = call_any_api(&tool, args.clone())
            .await
            .expect("tool call should succeed");

        response
            .parse::<u64>()
            .expect("response should be a unix timestamp");

        let direct = RigTool::call(&tool, args)
            .await
            .expect("direct call should succeed");
        assert_eq!(response, direct);
    }

    #[tokio::test]
    async fn name_description_and_validation_forward() {
        let tool = GetCurrentTime;
        let args = GetCurrentTimeParameters {
            topic: "Verify general tool plumbing".to_string(),
        };

        assert_eq!(AomiApiTool::name(&tool), GetCurrentTime::NAME);
        assert_eq!(AomiApiTool::description(&tool), GetCurrentTime::NAME);
        assert!(AomiApiTool::check_input(&tool, args.clone()));

        let output = AomiApiTool::call(&tool, args)
            .await
            .expect("call should succeed");
        output
            .parse::<u64>()
            .expect("response should be a unix timestamp");
    }
}
