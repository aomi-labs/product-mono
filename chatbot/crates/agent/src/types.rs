use std::future::Future;

/// Trait for external API tools with associated request and response types
pub trait AomiApiTool: Send + Sync {
    type ApiRequest: Send + Sync + Clone;
    type ApiResponse: Send + Sync + Clone;
    type Error: std::error::Error + Send + Sync + 'static;

    /// Execute an API call returning a future
    fn call(
        &self,
        request: Self::ApiRequest,
    ) -> impl Future<Output = Result<Self::ApiResponse, Self::Error>> + Send + Sync;

    /// Get the name of this API tool
    fn name(&self) -> &'static str;

    /// Get a description of what this API tool does
    fn description(&self) -> &'static str;

    fn check_input(&self, request: Self::ApiRequest) -> bool;
}

// Note: The specific tool implementations (AbiEncoderTool, WalletTransactionTool, TimeTool)
// have been removed since the Rig tools generated by #[rig_tool] macro already implement
// AomiApiTool through the generic implementation below.

// Generic implementation of AomiApiTool for Rig tools
impl<T> AomiApiTool for T
where
    T: rig::tool::Tool + Send + Sync + Clone,
    T::Args: serde::de::DeserializeOwned + Send + Sync + Clone,
    T::Output: serde::Serialize + Send + Sync + Clone,
    T::Error: std::error::Error + Send + Sync + 'static,
{
    type ApiRequest = T::Args;
    type ApiResponse = T::Output;
    type Error = T::Error;

    fn call(
        &self,
        request: Self::ApiRequest,
    ) -> impl Future<Output = Result<T::Output, T::Error>> + Send + Sync {
        self.call(request)
    }

    fn name(&self) -> &'static str {
        T::NAME
    }

    fn description(&self) -> &'static str {
        // Rig tools don't have a static description method, so we use the name
        T::NAME
    }

    fn check_input(&self, _request: Self::ApiRequest) -> bool {
        // No input validation by default - Rig tools handle their own validation
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::time::{GetCurrentTime, GetCurrentTimeParameters};
    use rig::tool::Tool as RigTool;

    async fn call_any_api<T>(tool: &T, request: T::ApiRequest) -> eyre::Result<T::ApiResponse>
    where
        T: AomiApiTool,
        T::Error: std::fmt::Display,
    {
        AomiApiTool::call(tool, request).await.map_err(Into::into)
    }

    #[tokio::test]
    async fn trait_dispatch_invokes_underlying_tool() {
        let tool = GetCurrentTime;
        let args = GetCurrentTimeParameters {};

        let response = call_any_api(&tool, args.clone())
            .await
            .expect("tool call should succeed");

        response
            .parse::<u64>()
            .expect("response should be a unix timestamp");

        let direct = RigTool::call(&tool, args)
            .await
            .expect("direct call should succeed");
        assert_eq!(response, direct);
    }

    #[tokio::test]
    async fn name_description_and_validation_forward() {
        let tool = GetCurrentTime;
        let args = GetCurrentTimeParameters {};

        assert_eq!(AomiApiTool::name(&tool), GetCurrentTime::NAME);
        assert_eq!(AomiApiTool::description(&tool), GetCurrentTime::NAME);
        assert!(AomiApiTool::check_input(&tool, args.clone()));

        let output = AomiApiTool::call(&tool, args)
            .await
            .expect("call should succeed");
        output
            .parse::<u64>()
            .expect("response should be a unix timestamp");
    }
}
