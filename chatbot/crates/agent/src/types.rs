use std::future::Future;

/// Trait for external API tools with associated request and response types
pub trait AomiApiTool: Send + Sync {
    type ApiRequest: Send + Sync + Clone;
    type ApiResponse: Send + Sync + Clone;
    type Error: std::error::Error + Send + Sync;

    /// Execute an API call returning a future
    fn call(
        &self,
        request: Self::ApiRequest,
    ) -> impl Future<Output = Result<Self::ApiResponse, Self::Error>> + Send + Sync;

    /// Get the name of this API tool
    fn name(&self) -> &'static str;

    /// Get a description of what this API tool does
    fn description(&self) -> &'static str;

    fn check_input(&self, request: Self::ApiRequest) -> bool;
}

// Note: The specific tool implementations (AbiEncoderTool, WalletTransactionTool, TimeTool)
// have been removed since the Rig tools generated by #[rig_tool] macro already implement
// AomiApiTool through the generic implementation below.

// Generic implementation of AomiApiTool for Rig tools
impl<T> AomiApiTool for T
where
    T: rig::tool::Tool + Send + Sync + Clone,
    T::Args: serde::de::DeserializeOwned + Send + Sync + Clone,
    T::Output: serde::Serialize + Send + Sync + Clone,
    T::Error: std::error::Error + Send + Sync,
{
    type ApiRequest = T::Args;
    type ApiResponse = T::Output;
    type Error = T::Error;

    fn call(
        &self,
        request: Self::ApiRequest,
    ) -> impl Future<Output = Result<T::Output, T::Error>> + Send + Sync {
        self.call(request)
    }

    fn name(&self) -> &'static str {
        T::NAME
    }

    fn description(&self) -> &'static str {
        // Rig tools don't have a static description method, so we use the name
        T::NAME
    }

    fn check_input(&self, _request: Self::ApiRequest) -> bool {
        // No input validation by default - Rig tools handle their own validation
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use serde::{Deserialize, Serialize};

    #[derive(Clone, Debug, Serialize, Deserialize)]
    struct DummyArgs {
        value: i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, Serialize)]
    struct DummyOutput {
        doubled: i32,
    }

    #[derive(Clone, Debug, Default)]
    struct DummyError;

    impl std::fmt::Display for DummyError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "dummy error")
        }
    }

    impl std::error::Error for DummyError {}

    #[derive(Clone)]
    struct DummyTool;

    impl rig::tool::Tool for DummyTool {
        const NAME: &'static str = "dummy_tool";
        type Error = DummyError;
        type Args = DummyArgs;
        type Output = DummyOutput;

        fn definition(
            &self,
            _prompt: String,
        ) -> impl Future<Output = rig::completion::ToolDefinition> + Send + Sync {
            std::future::ready(rig::completion::ToolDefinition {
                name: Self::NAME.to_string(),
                description: "Dummy tool used for unit tests".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "value": {
                            "type": "integer",
                            "description": "Input that will be doubled"
                        }
                    },
                    "required": ["value"]
                }),
            })
        }

        fn call(
            &self,
            args: Self::Args,
        ) -> impl Future<Output = Result<Self::Output, Self::Error>> + Send + Sync {
            std::future::ready(Ok(DummyOutput {
                doubled: args.value * 2,
            }))
        }
    }

    async fn call_any_api<T>(tool: &T, request: T::ApiRequest) -> Result<T::ApiResponse, String>
    where
        T: AomiApiTool,
        T::Error: std::fmt::Display,
    {
        AomiApiTool::call(tool, request)
            .await
            .map_err(|err| err.to_string())
    }

    #[tokio::test]
    async fn trait_dispatch_invokes_underlying_tool() {
        let tool = DummyTool;
        let args = DummyArgs { value: 21 };

        let response = call_any_api(&tool, args.clone())
            .await
            .expect("tool call should succeed");

        assert_eq!(response, DummyOutput { doubled: 42 });
    }

    #[tokio::test]
    async fn name_description_and_validation_forward() {
        let tool = DummyTool;
        let args = DummyArgs { value: 7 };

        assert_eq!(AomiApiTool::name(&tool), "dummy_tool");
        assert_eq!(AomiApiTool::description(&tool), "dummy_tool");
        assert!(AomiApiTool::check_input(&tool, args.clone()));

        let output = AomiApiTool::call(&tool, args)
            .await
            .expect("call should succeed");
        assert_eq!(output, DummyOutput { doubled: 14 });
    }
}
